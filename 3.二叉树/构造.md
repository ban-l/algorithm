# 构造

## 思路：分解问题

二叉树的构造问题一般都是使用「分解问题」的思路：

构造整棵树 = 根节点 + 构造左子树 + 构造右子树。

先找出根节点，然后根据根节点的值找到左右子树的元素，进而递归构建出左右子树。

## 1.顺序存储创建二叉树

对于顺序存储的完全二叉树，如果某个节点的索引为index，其对应的左子树的索引为2*index+1，右子树为2*index+2。

```java
/**
 * 顺序存储创建二叉树
 *
 * @param array 数组
 * @param index 索引
 * @return 树
 */
public TreeNode arrayToTree(int[] array, int index) {
    // 递归终止条件
    if (index >= array.length) {
        return null;
    }
    // 值为0，则是空结点
    if (array[index] == 0) {
        return null;
    }
    // 前序遍历
    // 生成节点，值为 array[index]
    TreeNode treeNode = new TreeNode(array[index]);
    // 左子树，索引为2*index+1
    treeNode.left = arrayToTree(array, 2 * index + 1);
    // 右子树，索引为2*index+2
    treeNode.right = arrayToTree(array, 2 * index + 2);
    return treeNode;
}

// arrayToTree(array, 0)
```

## 2.构造最大二叉树

- 先构造出根节点
- 然后递归调用构造左右子树

```java
public TreeNode build(int[] nums, int low, int high) {
    // base case
    if (low > high) return null;
    // 前序位置
    // 找到数组中的最大值，及索引
    int max = nums[low];
    int index = low;
    for (int i = low + 1; i <= high; i++) {
        if (nums[i] > max) {
            max = nums[i];
            index = i;
        }
    }
    // 先构造出根节点(最大值)
    TreeNode root = new TreeNode(max);
    // 递归调用构造左右子树
    root.left = build(nums, low, index - 1);
    root.right = build(nums, index + 1, high);
    return root;
}

// build(nums, 0, nums.length - 1)
```

## 3.从前序与中序遍历序列构造二叉树

- 根据前序、中序，确定一个节点位置
- 根据节点值找到左右子树的元素
- 然后递归构造左右子树，传入前序、中序遍历

## 4.从中序与后序遍历序列构造二叉树

- 根据中序、后序，确定一个节点位置
- 根据节点值找到左右子树的元素
- 然后     递归构造左右子树，传入中序、后序遍历

## 5.根据前序和后序遍历构造二叉树