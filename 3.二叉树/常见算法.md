# 常见算法

## 1.寻找二叉搜索树中的第 k 小的元素

```java
public int rank = 0;
public int res = 0;
public void traverse(TreeNode root, int k) {
    if (root == null) return;
    traverse(root.left, k);
    // 中序遍历 BST 从最小开始
    rank++;
    if (rank == k) {
        res = root.val;
        return;
    }
    traverse(root.right, k);
}
```

## 2.完全二叉树的节点个数

```java
public int countNodes(TreeNode root) {
    if (root == null) return 0;
    TreeNode left = root, right = root;
    // 沿最左侧和最右侧分别计算高度
    int hLeft = 0, hRight = 0;
    while (left != null) {
        left = left.left;
        hLeft++;
    }
    while (right != null) {
        right = right.right;
        hRight++;
    }
    // 如果左右侧计算的高度相同，则是一棵满二叉树
    if (hLeft == hRight) {
        return (int) Math.pow(2, hLeft) - 1;
    }
    // 如果左右侧的高度不同，则按照普通二叉树的逻辑计算（左+右+1）
    return 1 + countNodes(root.left) + countNodes(root.right);
}
```

