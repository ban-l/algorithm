# 常见算法

## 1.打印节点所在层数（前序遍历）

```java
public void traverse(TreeNode root, int depth) {
    if (root == null) {
        return;
    }
    // 前序位置
    System.out.println(root.val + " 在 第 " + depth + " 层");
    traverse(root.left, depth + 1);
    traverse(root.right, depth + 1);
}
```

## 2.打印节点左右子树各有多少节点（后序遍历）

```java
public int traverse(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftCount = traverse(root.left);
    int rightCount = traverse(root.right);
    //  后序位置
    System.out.println(root.val + " 左子树节点个数：" + leftCount + "，右子树节点个数：" + rightCount);
    return leftCount + rightCount + 1;
}
```

## 3.寻找二叉搜索树中的第 k 小的元素

```java
public int rank = 0;
public int res = 0;
public void traverse(TreeNode root, int k) {
    if (root == null) return;
    traverse(root.left, k);
    // 中序遍历 BST 从最小开始
    rank++;
    if (rank == k) {
        res = root.val;
        return;
    }
    traverse(root.right, k);
}
```

## 4.完全二叉树的节点个数

```java
/**
 * 利用完全二叉树的性质
 * 由于完全二叉树的性质，其子树
 * --有一棵一定是满二叉树，按照数学公式返回值，不会递归
 * --另一颗可能是满二叉树，也可能是完全二叉树，按照上述逻辑递归
 * <p>
 * 算法的递归深度就是树的高度 O(logN)，每次递归所花费的时间就是 while 循环，需要 O(logN)
 * 所以总体的时间复杂度是 O(logN*logN)
 */
public int countNodes(TreeNode root) {
    if (root == null) return 0;
    TreeNode left = root, right = root;
    // 沿最左侧和最右侧分别计算高度
    int hLeft = 0, hRight = 0;
    while (left != null) {
        left = left.left;
        hLeft++;
    }
    while (right != null) {
        right = right.right;
        hRight++;
    }
    // 如果左右侧计算的高度相同，则是一棵满二叉树
    if (hLeft == hRight) {
        return (int) Math.pow(2, hLeft) - 1;
    }
    // 如果左右侧的高度不同，则按照普通二叉树的逻辑计算（左+右+1）
    return 1 + countNodes(root.left) + countNodes(root.right);
}
```

## 5.节点最大深度

```java
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int l = maxDepth(root.left);
    int r = maxDepth(root.right);
    return Math.max(l, r) + 1;
}
```

## 6.二叉树的直径求节点的最大深度

### 前序遍历解法

```java
// 记录最大直径
public int res = 0;
/*
 * 前序遍历
 */
public void preorder(TreeNode root) {
    if (root == null) return;
    // 前序遍历
    // 先求左、右子树的最大深度
    int l = maxDepth(root.left);
    int r = maxDepth(root.right);
    // 当前节点的最大直径
    int nodeDiameter = l + r;
    // 更新全局最大直径
    res = Math.max(res, nodeDiameter);
    preorder(root.left);
    preorder(root.right);
}
```

### 后序遍历解法

```java
// 记录最大直径
public int res = 0;

/**
 * 后序遍历
 */
public int postorder(TreeNode root) {
    if (root == null) return 0;
    // 左、右子树的最大深度
    int l = postorder(root.left);
    int r = postorder(root.right);
    // 后续遍历
    // 根据左、右节点的最大深度，更新全局最大直径
    res = Math.max(res, l + r);
    // 返回当前节点最大深度
    return Math.max(l, r) + 1;
}
```

