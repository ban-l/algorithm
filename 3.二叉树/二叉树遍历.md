# 二叉树遍历

## 1.遍历

- 二叉树的遍历和遍历数组或者链表本质上没有区别；
- 链表和数组的遍历可以是迭代的，也可以是递归的；
- 二叉树结构，由于没法简单改写成迭代形式，所以一般来说，二叉树的遍历框架都是指**递归形式**；
- 递归形式的遍历，都有前序位置和后序位置，分别在递归之前和递归之后：
  - 前序位置，就是刚进入一个节点的时候；
  - 后序位置，就是即将离开一个节点的时候。

- 二叉树的前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点：
  - 前序位置的代码，在刚刚进入一个二叉树节点的时候执行；
  - 后序位置的代码，在将要离开一个二叉树节点的时候执行；
  - 中序位置的代码，在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

## 2.两种解题思路

遍历一遍二叉树得出答案（**回溯**）：

- 函数签名一般是 `void traverse(...)`，没有返回值，靠**更新外部变量**来计算结果。

分解问题计算出答案（**动态规划**）：

- 函数名根据函数具体功能而定，有返回值，返回值是**子问题计算结果**。

## 3.思考

- 二叉树的所有问题，就是在前中后序位置注入巧妙的代码逻辑，去达到自己的目的。
- 单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前中后序）做？
- 其他的节点不用你操心，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。

## 4.前序位置和后序位置

### 前序位置的代码执行：自顶向下

前序位置的代码只能从函数参数中获取父节点传递来的数据。

### 后序位置的代码执行：自底向上

后序位置的代码不仅可以获取**参数数据**，还可以获取到子树通过**函数返回值**传递回来的数据。

### 问题1: 如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？（前序遍历）

```java
public void traverse(TreeNode root, int depth) {
    if (root == null) {
        return;
    }
    // 前序位置
    System.out.println(root.val + " 在 第 " + depth + " 层");
    traverse(root.left, depth + 1);
    traverse(root.right, depth + 1);
}
```

### 问题2: 如何打印出每个节点的左右子树各有多少节点？（后序遍历）

```java
public int traverse(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftCount = traverse(root.left);
    int rightCount = traverse(root.right);
    //  后序位置
    System.out.println(root.val + " 左子树节点个数：" + leftCount + "，右子树节点个数：" + rightCount);
    return leftCount + rightCount + 1;
}
```

这两个问题的根本区别在于：

- 一个节点在第几层，从根节点遍历过来的过程就能顺带记录，用递归函数的参数就能传递下去；
- 一个节点为根的整棵子树有多少个节点，需要遍历完子树之后才能数清楚，然后通过递归函数的返回值拿到答案。

### 只有后序位置才能通过返回值获取子树信息 

一旦题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。

## 5.BST（中序位置）

中序位置主要用在 BST 场景中，可以把 BST 的中序遍历认为是遍历有序数组。

## 6.动规/DFS/回溯（子树/节点/树枝）

动规/DFS/回溯算法都可以看做二叉树问题的扩展，只是它们的关注点不同：

1. 动态规划算法属于**分解**问题的思路，它的关注点在整棵「**子树**」。
2. DFS 算法属于**遍历**的思路，它的关注点在单个「**节点**」。
3. 回溯算法属于**遍历**的思路，它的关注点在节点间的「**树枝**」。
   - 它的着眼点永远是在节点之间移动的过程，类比到二叉树上就是「树枝」。

### DFS算法 「做选择」和「撤销选择」的逻辑放在 for 循环外面

```java
public void dfs(Node root) {
    if (root == null) return;
    // 做选择
    System.out.println("进入节点");
    for (Node child : root.getChildren()) {
        dfs(child);
    }
    // 撤销选择
    System.out.println("离开节点");
}
```

### 回溯算法「做选择」和「撤销选择」的逻辑放在 for 循环里面

```java
public void backtrack(Node root) {
    if (root == null) return;
    for (Node child : root.getChildren()) {
        // 做选择
        System.out.println("节点树枝");
        backtrack(child);
        // 撤销选择
        System.out.println("节点树枝");
    }
}
```

