# 思路

**遍历：遍历一遍**二叉树得出答案（**回溯**）

- 二叉树中用遍历思路解题时函数签名一般是 void traverse(...)
- 没有返回值，靠更新外部变量来计算结果

**分解问题**：通过**分解**问题计算出答案（**动态规划**）

- 分解问题思路解题时函数名根据该函数具体功能而定
- 而且一般会有**返回值**，**返回值**是**子问题的计算结果**。

 

**无论使用哪种思维模式，都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。**

## 常见问题

1. 如果把根节点看做第 1 层，如何打印出每一个节点所在的层数
   1. 前序遍历
2. 如何打印出每个节点的左右子树各有多少节点？
   1. 后序遍历
3. 二叉树最大深度
   1. 回溯，维护外部变量
   2. 动态规划，返回值是结果
4. 二叉树层次遍历
   1. 队列
   2. 从上到下遍历二叉树的每一层
   3. 从左到右遍历每一层的每个节点
5. 倒序打印链表
   1. 后序位置
6. 给你一棵二叉树的根节点，返回该树的 直径
   1. 左 + 右节点的最大深度，全局最大直径
7. 寻找二叉搜索树中的第 k 小的元素
   1. 中序遍历 BST 从最小开始
   2. 维护外部变量，更新结果
8. 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。
   1. 前序「遍历」
   2. 后序「分解问题」
9. 填充每个节点的下一个右侧节点指针
   1. 前序「遍历」
   2. 一棵二叉树被抽象成了一棵三叉树，三叉树上的每个节点就是原先二叉树的两个相邻节点。
10. 二叉树展开为链表
    1. 后序遍历，分解问题
       1. 先把root左子树  变为 root右子树，
       2. 再把原来的 root右子树  链接到 root的右叶子节点（原来左子树的右叶子节点）
    2. 前序遍历，构建一个新的链表,需要额外的空间
    3. 借用辅助集合：先前序遍历得到 result 集合，然后root依次添加 右节点为 result 中的元素