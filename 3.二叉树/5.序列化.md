# 序列化

## 前/中/后序和二叉树的唯一性

### 反序列化出唯一的一棵二叉树

**当二叉树中节点的值不存在重复时：**

1. 如果序列化结果中**不包含空指针**的信息，且只给出**一种**遍历顺序，那么**无法还原出唯一**的一棵二叉树。
2. 如果序列化结果中**不包含空指针**的信息，且会给出**两种**遍历顺序，分**两种情况**：
   1. 如果是**前序和中序**，或者，**中序和后序**，那么可以**还原出唯一**的一棵二叉树。
   2. 如果**前序和后序**，那么**无法还原**出唯一的一棵二叉树。
3. 如果序列化结果中**包含空指针**的信息，且只给出**一种**遍历顺序，也要分两种情况：
   1. 如果是**前序或者后序**，那么可以**还原出唯一**的一棵二叉树。
   2. 如果是**中序**，那么**无法还原**出唯一的一棵二叉树。

### 打平

所谓的序列化不过就是把结构化的数据「打平」，本质就是在考察二叉树的遍历方式。

## 例题：寻找重复的子树

给你一棵二叉树的根节点 `root` ，返回所有 **重复的子树** 。

对于同一类的重复子树，你只需要返回其中任意 **一棵** 的根结点即可。

如果两棵树具有 **相同的结构** 和 **相同的结点值** ，则认为二者是 **重复** 的。

### 示例

```
输入：root = [1,2,3,4,null,2,4,null,null,4]
输出：[[2,4],[4]]

输入：root = [2,1,1]
输出：[[1]]

输入：root = [2,2,2,3,null,3,null]
输出：[[2,3],[3]]
```

### 思路

1. 后序位置
2. 记录每个子树的序列化结果（String）
3. 统计子树序列化结果的出现次数（有重复的）
4. 找出重复子树

### 代码实现

```java
// 记录所有子树(序列化结果)以及出现的次数
public Map<String, Integer> map = new HashMap<>();
// 记录重复的子树根节点
public List<TreeNode> res = new LinkedList<>();

/**
 * 1.记录每个子树的序列化结果（String）
 * 2.统计子树序列化结果的出现次数（有重复的）
 * 3.找出重复子树
 */
public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
    serialize(root);
    return res;
}
/**
 * 输入以 root 为根的二叉树，返回这棵树的序列化字符串
 */
public String serialize(TreeNode root) {
    // 对于空节点，可以用一个特殊字符表示
    if (root == null) {
        return "#";
    }
    // 将左、右子树序列化成字符串
    String left = serialize(root.left);
    String right = serialize(root.right);
    // 后序遍历代码位置
    // 左、右子树加上自己，就是以自己为根的二叉树序列化结果
    String myself = left + "," + right + "," + root.val;
    int freq = map.getOrDefault(myself, 0);
    // 多次重复也只会被加入结果集一次
    if (freq == 1) {
        res.add(root);
    }
    // 给子树对应的出现次数加一
    map.put(myself, freq + 1);
    return myself;
}
```

