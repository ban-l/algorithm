# 负载均衡算法

负载均衡算法是分布式系统和高可用架构的核心组成部分，其目标是将网络请求或计算任务合理地分配到多个服务器（或称为节点、实例）上，以实现最大化吞吐量、最小化响应时间、避免单点过载、提高系统容错能力。

负载均衡算法主要分为两大类：**静态负载均衡算法** 和 **动态负载均衡算法**。

---

### 一、静态负载均衡算法

静态算法不关心服务器当前的实时负载状态（如CPU、内存使用率等），只根据预先设定的规则进行分配。实现简单，开销小，但无法应对服务器性能波动或突发故障。

#### 1. 轮询 (Round Robin, RR)
*   **原理**：这是最简单、最经典的算法。负载均衡器将收到的请求按顺序依次分配给后端服务器列表中的每一台服务器。分配完最后一台后，又回到第一台，循环往复。
*   **示例**：有3台服务器 A, B, C。
    请求1 -> A， 请求2 -> B， 请求3 -> C， 请求4 -> A， 请求5 -> B ...
*   **优点**：绝对公平，实现简单。
*   **缺点**：无法考虑服务器之间的性能差异。如果某台服务器性能较差，它仍然会接收到同样多的请求，可能最终会变慢甚至宕机。

#### 2. 加权轮询 (Weighted Round Robin, WRR)
*   **原理**：在轮询算法的基础上，为每台服务器赋予一个权重（Weight），代表其处理能力的相对比例。性能越高的服务器权重越大，接收到的请求也就越多。
*   **示例**：服务器 A(权重5), B(权重1), C(权重1)。负载均衡器会按比例分配请求，例如在7个请求中，A会收到5个，B和C各收到1个，然后再循环。
*   **优点**：考虑了服务器硬件性能的差异，使分配更合理。
*   **缺点**：权重是静态设置的，无法根据服务器当前的实时负载（如CPU高低）进行动态调整。

#### 3. 随机 (Random)
*   **原理**：完全随机地从服务器列表中选取一台来处理当前请求。
*   **优点**：实现极其简单。
*   **缺点**：无法保证公平性，运气不好可能导致大量请求集中到某一台服务器上（虽然在大样本下会趋于平均）。通常用于简单场景或作为其他算法的补充。

#### 4. 加权随机 (Weighted Random)
*   **原理**：与加权轮询类似，但选择过程是随机的。权重越高的服务器，被随机选中的概率越大。
*   **优点**：同样考虑了服务器性能差异。
*   **缺点**：和加权轮询一样，无法动态调整。

#### 5. 源地址哈希 (Hash)
*   **原理**：提取客户端的IP地址（或会话ID等其他固定信息），通过一个哈希函数计算出一个数值，用这个数值对服务器列表大小进行取模运算，得到目标服务器的索引。
    *   `index = hash(key) % N` (N为服务器数量)
*   **优点**：**会话保持（Session Affinity）**。同一个源IP的请求总是会被分配到同一台服务器上，这对于需要保持用户会话状态（如购物车、登录信息）的应用至关重要。
*   **缺点**：
    1.  **服务器数量变化导致缓存失效**：当服务器数量（N）发生变化（增删服务器）时，取模的结果会发生巨大变化，导致大部分请求被路由到错误的服务器上，之前的会话信息丢失。这被称为**重哈希问题**。
    2.  无法保证负载绝对均匀，如果某些IP的请求量特别大，会导致其对应的服务器压力过大。

#### 6. 一致性哈希 (Consistent Hashing)
*   **原理**：为了解决源地址哈希的重哈希问题而设计。
    1.  将服务器节点和请求的Key（如IP）都映射到一个固定的哈希环上（通常是一个0~2^32-1的圆环）。
    2.  当一个请求到来时，计算其Key的哈希值，在环上顺时针寻找第一个遇到的服务器节点，该节点即为要路由的目标服务器。
    3.  当增删节点时，**只会影响环上相邻的一小部分请求**，大部分请求仍然会路由到原来的服务器，完美解决了重哈希问题。
*   **优点**：极大地降低了服务器扩缩容时带来的数据迁移成本和会话中断问题。是现代分布式系统（如Redis Cluster, Memcached）的基石算法。
*   **缺点**：实现比简单哈希复杂。可能存在数据倾斜问题（可通过引入“虚拟节点”解决）。

---

### 二、动态负载均衡算法

动态算法会考虑服务器的实时运行状态（如连接数、响应时间、系统负载等）来做出决策，更加智能，但实现更复杂，需要收集服务器指标，开销更大。

#### 1. 最小连接数 (Least Connections)
*   **原理**：负载均衡器记录每个服务器当前正在处理的活跃连接数（或请求数），将新的请求分配给当前连接数最少的服务器。
*   **优点**：非常符合直觉，能动态地将负载压力均匀分散，特别适合处理**长连接**场景（如WebSocket、数据库连接池）。
*   **缺点**：需要服务器主动上报或负载均衡器主动探测连接数，增加了复杂性。没有考虑服务器性能差异。

#### 2. 加权最小连接数 (Weighted Least Connections)
*   **原理**：最小连接数算法的增强版。将每台服务器的当前连接数除以其权重，然后选择 `(当前连接数 / 权重)` 值最小的那台服务器。
*   **优点**：既考虑了服务器的实时负载，又考虑了其静态性能差异，是目前非常常用且高效的算法。

#### 3. 最短响应时间 (Least Response Time)
*   **原理**：负载均衡器会探测后端服务器的响应速度（通常是平均响应时间或最新响应时间），将请求分配给响应时间最短的服务器。
*   **优点**：从客户端体验的角度出发，致力于让用户获得最快的响应。
*   **缺点**：测量响应时间本身就有延迟和开销，可能不够准确。网络抖动可能会干扰判断。

#### 4. 基于负载状态
*   **原理**：负载均衡器通过代理（Agent）或API从服务器获取更详细的系统指标，如**CPU使用率、内存使用率、磁盘I/O、网络I/O**等，然后根据一个综合算法（如选择CPU最低的）来选择目标服务器。
*   **优点**：最为智能，能从根因上避免服务器过载。
*   **缺点**：实现最为复杂，监控数据的采集和传输会带来额外的性能和网络开销。

---

### 总结与对比

| 算法               | 类型 | 优点                             | 缺点                   | 适用场景                             |
| :----------------- | :--- | :------------------------------- | :--------------------- | :----------------------------------- |
| **轮询 (RR)**      | 静态 | 绝对公平，简单                   | 忽略性能差异和当前状态 | 服务器硬件配置完全一致，且负载平稳   |
| **加权轮询 (WRR)** | 静态 | 考虑静态性能差异                 | 忽略当前状态           | 服务器硬件配置不一致，但负载波动不大 |
| **源地址哈希**     | 静态 | 实现会话保持                     | 扩缩容时问题严重       | 需要保持会话状态的应用               |
| **一致性哈希**     | 静态 | 优秀会话保持，扩缩容影响小       | 实现稍复杂             | 分布式缓存、有状态服务               |
| **最小连接数**     | 动态 | 动态分配，处理长连接效果好       | 忽略性能差异           | 处理时间长短不一的连接（如TCP应用）  |
| **加权最小连接数** | 动态 | **综合性能最好**，兼顾静态与动态 | 实现复杂               | **通用场景的首选**                   |
| **最短响应时间**   | 动态 | 优化客户端体验                   | 测量有开销和误差       | 对响应速度敏感的应用                 |
| **基于负载状态**   | 动态 | 最智能，避免过载                 | 实现最复杂，开销大     | 对系统稳定性要求极高的关键业务       |

在实际生产中，**加权最小连接数** 和 **一致性哈希** 是使用最为广泛的两种算法。选择哪种算法完全取决于你的具体业务需求：
*   **需要会话保持吗？** -> **一致性哈希**
*   **后端服务器性能一致吗？** -> 不一致就需要**加权**算法
*   **请求是短连接还是长连接？** -> 长连接更适合**最小连接数**
*   **服务器集群需要频繁扩缩容吗？** -> 需要则必须考虑**一致性哈希**