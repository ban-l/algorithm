# 阶乘算法

## 一、阶乘后的零

### 题目描述

给定一个整数 n ，返回 n! 结果中尾随零的数量。

提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1

即：阶乘 n! 的结果末尾有几个 0

### 示例 1：

- 输入：n = 3

- 输出：0

- 解释：3! = 6 ，不含尾随 0

### 示例 2：

- 输入：n = 5
- 输出：1
- 解释：5! = 120 ，有一个尾随 0

### 示例 3：

- 输入：n = 0
- 输出：0

### 思路

肯定不可能真去把 n! 的结果算出来，阶乘增长可是比指数增长都恐怖。

那么，结果的末尾的 0 从哪里来的？

首先，两个数相乘结果末尾有 0，一定是因为两个数中有因子 2 和 5，因为 10 = 2 x 5。

#### 问题转化为：n! 最多可以分解出多少个因子 2 和 5？ 

比如说 n = 25，那么 25! 最多可以分解出几个 2 和 5 相乘？

这个主要取决于能分解出几个因子 5，因为每个偶数都能分解出因子 2，因子 2 肯定比因子 5 多得多。

25! 中 5 可以提供一个，10 可以提供一个，15 可以提供一个，20 可以提供一个，25 可以提供两个，

总共有 6 个因子 5，所以 25! 的结果末尾就有 6 个 0。

#### 问题转化为：n! 最多可以分解出多少个因子 5？

难点在于像 25，50，125 这样的数，可以提供不止一个因子 5，怎么才能不漏掉呢？

#### 假设 n = 125，来算一算 125! 的结果末尾有几个 0

1. 首先，**125 / 5 = 25**，这一步就是计算有多少个像 5，15，20，25 这些 5 的倍数，它们一定可以提供一个因子 5。
2. 但是，这些足够吗？刚才说了，像 25，50，75 这些 25 的倍数，可以提供两个因子 5，
3. 那么我们再计算出 125! 中有 **125 / 25 = 5** 个 25 的倍数，它们每人可以额外再提供一个因子 5。
4. 够了吗？我们发现 125 = 5 x 5 x 5，像 125，250 这些 125 的倍数，可以提供 3 个因子 5，
5. 那么我们还得再计算出 125! 中有 **125 / 125 = 1** 个 125 的倍数，它还可以额外再提供一个因子 5。
6. 这下应该够了，125! 最多可以分解出 **25 + 5 + 1 = 31** 个因子 5，也就是说阶乘结果的末尾有 31 个 0。

### 代码实现

```java
/**
 * 阶乘后的零
 * 给定一个整数 n ，返回 n! 结果中尾随零的数量。
 * 提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1
 */
public class TrailingZeroes {
    public int trailingZeroes(int n) {
        int res = 0;
        long divisor = 5;
        while (divisor <= n) { // 跳出循环
            res += (int) (n / divisor); // 5、25、125....提供的5 累加计数
            divisor *= 5; // 更新 divisor：5、25、125....
        }
        return res;
    }

    public static void main(String[] args) {
        TrailingZeroes trailingZeroes = new TrailingZeroes();
        int res = trailingZeroes.trailingZeroes(125);
        System.out.println(res); // 31
    }
}
```

