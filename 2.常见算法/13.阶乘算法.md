# 阶乘算法

## 一、阶乘后的零

### 题目描述

```text
给定一个整数 n ，返回 n! 结果中尾随零的数量。

提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1

即：阶乘 n! 的结果末尾有几个 0

示例 1：
- 输入：n = 3
- 输出：0
- 解释：3! = 6 ，不含尾随 0

示例 2：
- 输入：n = 5
- 输出：1
- 解释：5! = 120 ，有一个尾随 0

示例 3：
- 输入：n = 0
- 输出：0
```

### 思路

肯定不可能真去把 n! 的结果算出来，阶乘增长可是比指数增长都恐怖。

那么，结果的末尾的 0 从哪里来的？

首先，两个数相乘结果末尾有 0，一定是因为两个数中有因子 2 和 5，因为 10 = 2 x 5。

#### 问题转化为：n! 最多可以分解出多少个因子 2 和 5？ 

比如说 n = 25，那么 25! 最多可以分解出几个 2 和 5 相乘？

这个主要取决于能分解出几个因子 5，因为每个偶数都能分解出因子 2，因子 2 肯定比因子 5 多得多。

25! 中 5 可以提供一个，10 可以提供一个，15 可以提供一个，20 可以提供一个，25 可以提供两个，

总共有 6 个因子 5，所以 25! 的结果末尾就有 6 个 0。

#### 问题转化为：n! 最多可以分解出多少个因子 5？

难点在于像 25，50，125 这样的数，可以提供不止一个因子 5，怎么才能不漏掉呢？

#### 假设 n = 125，来算一算 125! 的结果末尾有几个 0

1. 首先，**125 / 5 = 25**，这一步就是计算有多少个像 5，15，20，25 这些 5 的倍数，它们一定可以提供一个因子 5。
2. 但是，这些足够吗？刚才说了，像 25，50，75 这些 25 的倍数，可以提供两个因子 5，
3. 那么我们再计算出 125! 中有 **125 / 25 = 5** 个 25 的倍数，它们每人可以额外再提供一个因子 5。
4. 够了吗？我们发现 125 = 5 x 5 x 5，像 125，250 这些 125 的倍数，可以提供 3 个因子 5，
5. 那么我们还得再计算出 125! 中有 **125 / 125 = 1** 个 125 的倍数，它还可以额外再提供一个因子 5。
6. 这下应该够了，125! 最多可以分解出 **25 + 5 + 1 = 31** 个因子 5，也就是说阶乘结果的末尾有 31 个 0。

### 代码实现

```java
/**
 * 阶乘后的零
 * 给定一个整数 n ，返回 n! 结果中尾随零的数量。
 * 提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1
 */
public class TrailingZeroes {
    public int trailingZeroes(int n) {
        int res = 0;
        long divisor = 5;
        while (divisor <= n) { // 跳出循环
            res += (int) (n / divisor); // 5、25、125....提供的5 累加计数
            divisor *= 5; // 更新 divisor：5、25、125....
        }
        return res;
    }

    public static void main(String[] args) {
        TrailingZeroes trailingZeroes = new TrailingZeroes();
        int res = trailingZeroes.trailingZeroes(125);
        System.out.println(res); // 31
    }
}
```

## 二、阶乘函数后 K 个零

### 题目描述

```text
f(x) 是 x! 末尾是 0 的数量。回想一下 x! = 1 * 2 * 3 * ... * x，且 0! = 1 。
例如
- f(3) = 0 ，因为 3! = 6 的末尾没有 0 ；
- f(11) = 2 ，因为 11!= 39916800 末端有 2 个 0 。

给定 k，找出返回能满足 f(x) = k 的非负整数 x 的数量。

即：现在是给你一个非负整数 K，问你有多少个 n，使得 n! 结果末尾有 K 个 0。
```

### trailingZeroes（阶乘后的零）是一个递增函数

- 随着n的增大，n!是递增的，trailingZeroes(n!) 也是递增的
- 递增函数：阶乘 n! 的结果末尾有几个 0

例如

- n = 24、25、26、27、28、29、30

- trailingZeroes(n!)  = 4、6、6、6、6、7

### 思路1：穷举

```java
public int exhaustion(int k) {
    int res = 0;
    for (int n = 0; n < Integer.MAX_VALUE; n++) {
        // n!末尾 0 大于 k，跳出循环，trailingZeroes是递增的，后面也都大于k
        long count = trailingZeroes(n);
        if (count > k) break;
        // n!末尾 0 小于 k，继续
        if (count < k) continue;
        // n!末尾 0 等于 k，累加
        res++;
    }
    return res;
}
```

### 思路2：二分查找 「搜索左侧边界」和「搜索右侧边界」

**f(n)随着n的递增而递增，求f(n)==k的个数（有序序列查找，二分查找）**

其实在问：满足条件的 n 最小是多少，最大是多少，最大值和最小值一减，就可算出有多少个 n 满足条件了

答案即为 n 的右边界和左边界之差 + 1

### 二分查找搜索区间

K 是在 [0, 10^9] 区间内的整数，也就是说，trailingZeroes(n) 的结果最多可以达到 10^9

反推，当 trailingZeroes(n) 结果为 10^9 时，n 为多少？

不需要精确计算出来，只要找到一个数 hi，使得 trailingZeroes(hi) 比 10^9 大，就可以把 hi 当做正无穷，作为搜索区间的上界。

- trailingZeroes（Integer.MAX_VALUE）的结果，比 10^9 小一些
- trailingZeroes（Long.MAX_VALUE）的结果，远超 10^9，所以Long.MAX_VALUE 可以作为搜索的上界。

注意为了避免整型溢出的问题，trailingZeroes 函数需要把所有数据类型改成 long

### 代码实现

```java
public class PreimageSizeFZF {

    /**
     * 左、右边界的二分查找
     * 搜索有多少个 n 满足 trailingZeroes(n) == K
     * 其实就是在问：满足条件的 n 最小是多少，最大是多少，最大值和最小值一减，就可以算出来有多少个 n 满足条件了
     * 即 二分查找 中「搜索左侧边界」和「搜索右侧边界」
     * 结果为： 右边界和左边界之差 + 1
     */
    public int preimageSizeFZF(int k) {
        // 右边界和左边界之差 + 1
        return (int) (rightBound(k) - leftBound(k) + 1);
    }

    /**
     * 二分查找，搜索 trailingZeroes(n) == K 的左侧边界
     */
    public long leftBound(int k) {
        long lo = 0;
        long hi = Long.MAX_VALUE;
        while (lo <= hi) {
            long mid = lo + (hi - lo) / 2;
            long count = trailingZeroes(mid);
            if (count > k) {
                hi = mid - 1;
            } else if (count < k) {
                lo = mid + 1;
            } else if (count == k) {
                hi = mid - 1;
            }
        }
        return lo;
    }

    /**
     * 二分查找，搜索 trailingZeroes(n) == K 的右侧边界
     */
    public long rightBound(int k) {
        long lo = 0;
        long hi = Long.MAX_VALUE;
        while (lo <= hi) {
            long mid = lo + (hi - lo) / 2;
            long count = trailingZeroes(mid);
            if (count > k) {
                hi = mid - 1;
            } else if (count < k) {
                lo = mid + 1;
            } else if (count == k) {
                lo = mid + 1;
            }
        }
        return hi;
    }

    /**
     * 递增函数：阶乘 n! 的结果末尾有几个 0
     * 随着n的增大，n!是递增的，trailingZeroes(n!) 也是递增的
     */
    public long trailingZeroes(long n) {
        long res = 0;
        long divisor = 5;
        while (divisor <= n) { // 跳出循环
            res += n / divisor; // 5、25、125....提供的5 累加计数
            divisor *= 5; // 更新 divisor：5、25、125....
        }
        return res;
    }

}

```

