# 随机算法

## 问题：在若干个元素中随机选择 k 个元素

需要随机选出 k 个不同的位置。那在 [0, m * n) 中选出来 k 个随机数不就行了？

可以，但实际操作起来有些麻烦，因为你很难保证随机数不重复。

如果出现重复的随机数，你就得再随机选一次，直到找到 k 个不同的随机数。

如果 k 比较小，m * n 比较大，那出现重复随机数的概率还比较低。

但如果 k 和 m * n 的大小接近，那么出现重复随机数的概率非常高，算法的效率就会大幅下降。

## 解法1：洗牌算法

可以换个思路，避开 ”在数组中随机选择 k 个元素“ 问题，把问题转化成**”如何随机打乱一个数组“**。

给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是等可能的。

分析洗牌算法正确性的准则：产生的结果必须有 n! 种可能。

这个很好解释，因为一个长度为 n 的数组的全排列就有 n! 种，也就是说打乱结果总共有 n! 种。

算法必须能够反映这个事实，才是正确的。

```text
对于 nums[0]，我们把它随机换到了索引 [0, n) 上，共有 n 种可能性；
对于 nums[1]，我们把它随机换到了索引 [1, n) 上，共有 n - 1 种可能性；
对于 nums[2]，我们把它随机换到了索引 [2, n) 上，共有 n - 2 种可能性；
以此类推，该算法可以生成 n! 种可能的结果，所以这个算法是正确的，能够保证随机性。
```

**洗牌算法能够生效的前提：使用数组（随机访问）。**

### 代码实现

```java
public class Shuffle {

    private final int[] nums;
    private final Random rand = new Random();

    public Shuffle(int[] nums) {
        this.nums = nums;
    }

    public int[] reset() {
        return nums;
    }

    /**
     * 洗牌算法
     */
    public int[] shuffle() {
        int n = nums.length;
        int[] copy = Arrays.copyOf(nums, n);
        for (int i = 0; i < n; i++) {
            // 生成一个随机数，范围：[i,n)
            int r = i + rand.nextInt(n - i);
            swap(copy, i, r);
        }
        return copy;
    }

    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    
}

```

## 解决2：水塘抽样算法

在若干元素中随机选择 k 个元素，常见的随机抽样场景，常用的解法是**水塘抽样算法**（Reservoir Sampling）

### 例题：返回链表中一个随机节点的值

#### 常规做法

1. 先**遍历一遍**链表，得到链表的总长度 n，
2. 再生成一个 [0,n-1) 之间的随机数为索引,
3. 然后找到索引对应的节点（**遍历第二遍**）。

但这不符合只能遍历一次链表的要求。

```java
public int getRandomNumber(ListNode head) {
    // 第一次遍历，求出长度
    int len = 0;
    ListNode p = head;
    while (p != null) {
        len++;
        p = p.next;
    }
    // 生成[0,len)的随机数 为索引 r
    int r = new Random().nextInt(len);
    int res = 0; // 答案
    int count = 0; // 索引移动
    p = head;
    // 第二次遍历
    while (p != null) {
        // 返回索引 r 对应的节点值
        if (r == count) {
            res = p.val;
            break;
        }
        count++;
        p = p.next;
    }
    return res;
}
```

#### 水塘抽样

**水塘抽样：当遇到第 i 个元素时，应该有 1/i 的概率选择该元素，1 - 1/i 的概率保持原有的选择。** 

```java
public int getRandomNumber(ListNode head) {
    Random r = new Random();
    int i = 0, res = 0;
    ListNode p = head;
    // while 循环遍历链表
    while (p != null) {
        i++;
        // 生成一个 [0, i) 之间的整数，共 i 种可能性
        // 这个整数等于 0 的概率就是 1/i
        if (0 == r.nextInt(i)) {
            res = p.val;
        }
        p = p.next;
    }
    return res;
}
```

### 例题：单链表中随机选择 k 个数

```java
public int[] getRandomNumber(ListNode head, int k) {
    Random r = new Random();
    int[] res = new int[k];
    ListNode p = head;
    // 前 k 个元素先默认选上
    for (int i = 0; i < k && p != null; i++) {
        res[i] = p.val;
        p = p.next;
    }
    int i = k;
    while (p != null) {
        i++;
        // 生成一个 [0, i) 之间的整数，共 i 种可能性
        // 1/i的概率 == [0, i) 之间的整数
        int j = r.nextInt(i);
        // 这个随机数 j 小于 k 的概率就是 k/i（k种可能）
        if (j < k) {
            res[j] = p.val;
        }
        p = p.next;
    }
    return res;
}
```

