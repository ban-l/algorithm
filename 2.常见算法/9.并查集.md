# 并查集

## 概念

**并查集（不交集数据结构，不重复）是一种树形数据结构**，用于处理一些**不交集的合并及查询**问题。

并查集支持如下操作：

- **Find（查找）**：查询某个元素属于哪个集合，通常是返回集合内的一个“代表元素”，用于判断两个元素是否在同一个集合之中。
- **Union（合并）**：将把两个不相交的集合合并为一个集合。

## 核心思想

- 每个集合用一棵树表示；
- 树的根节点作为该集合的"代表元"；
- 每个节点保存一个指向父节点的引用；
- 根节点的父节点指向自身。

## 操作

### 1.初始化

- 用一个数组 fa[] 来存储每个元素的父节点，一开始，每个元素的父节点设为自己。

### 2.Find操作

查找元素所在集合的根节点（代表元素）。

- 对于某个点x，查询属于哪个集合，返回其所属集合的代表元，以此判断两个元素是否在一个集合内。
- 一层一层访问父节点，直至根节点（父节点是本身）(代表元)。

### 3.Union操作

合并两个元素所在的集合。

- 先找到两个集合的代表元，然后将前者的父节点设为后者。
- 当然也可以将后者的父节点设为前者。

## 优化策略

### 路径压缩：优化Find

在Find操作中，将查找路径上的所有节点直接连接到根节点，降低树的高度。

- 把沿途的每个节点的父节点都设为根节点，降低树的高度；
- 第一次查询没有压缩效果，之后才有效。

###  路径压缩：按秩合并

- 总是将较小的树合并到较大的树上；
- "秩"可以是树的高度或节点数量；
- 避免树退化成链表。

具体实现步骤：

- 使用数组`rank[]`，记录每个根节点对应的树的深度（不是根节点，rank为子树深度）；
- 初始(rank)秩设为1，合并时，秩较小者往较大者合并；
- 如果`rank[x]<rank[y]`，`fa[x]=y`；
- 如果`rank[x]==rank[y]`，任意指定父节点；
- 如果`rank[x]>rank[y]`， `x=fa[y]`。

## 应用场景

### 连通性问题

1. 计算连通分量数量：
   - 如果一个图中所有点都存在可达关系（直接或间接相连），则此图的连通分支数为1；
   - 如果此图有两大子图各自全部可达，则此图的连通分支数为2；
2. 判断两个点是否在同一连通块内；
3. 增加一条边后是否会产生环；
4. 用于求解最小生成树：Kruskal算法。

### 朋友圈问题

### 岛屿数量问题