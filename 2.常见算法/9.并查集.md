# 并查集

## 概念

并查集，Disjoint Set Union，简称DSU。

**并查集（不交集数据结构，不重复）是一种树形数据结构**，用于处理一些**不相交集合的合并及查询**问题。

并查集支持如下操作：

- **Find（查找）**：查询某个元素属于哪个集合，通常是返回集合内的一个“代表元素”，用于判断两个元素是否在同一个集合之中。
- **Union（合并）**：将把两个不相交的集合合并为一个集合。

## 核心思想

- 每个集合用一棵树表示；
- 树的根节点作为该集合的"代表元"；
- 每个节点保存一个指向父节点的引用；
- 根节点的父节点指向自身。

## 操作

### 1.初始化

- 用一个数组 fa[] 来存储每个元素的父节点，一开始，每个元素的父节点设为自己。

### 2.Find操作

查找元素所在集合的根节点（代表元素）。

- 对于某个点x，查询属于哪个集合，返回其所属集合的代表元，以此判断两个元素是否在一个集合内。
- 一层一层访问父节点，直至根节点（父节点是本身）(代表元)。

### 3.Union操作

合并两个元素所在的集合。

- 先找到两个集合的代表元，然后将前者的父节点设为后者。
- 当然也可以将后者的父节点设为前者。

## 优化策略

### 路径压缩：优化Find

在Find操作中，将查找路径上的所有节点直接连接到根节点，降低树的高度。

- 把沿途的每个节点的父节点都设为根节点，降低树的高度；
- 第一次查询没有压缩效果，之后才有效。

###  按秩合并：优化Union

- 总是将较小的树合并到较大的树上；
- "秩"可以是树的高度或节点数量；
- 避免树退化成链表。

具体实现步骤：

- 使用数组`rank[]`，记录每个根节点对应的树的深度（不是根节点，rank为子树深度）；
- 初始(rank)秩设为1，合并时，秩较小者往较大者合并；
- 如果`rank[x]<rank[y]`，`fa[x]=y`；
- 如果`rank[x]==rank[y]`，任意指定父节点；
- 如果`rank[x]>rank[y]`， `x=fa[y]`。

## 应用场景

### 连通性问题

1. 计算连通分量数量：
   - 如果一个图中所有点都存在可达关系（直接或间接相连），则此图的连通分支数为1；
   - 如果此图有两大子图各自全部可达，则此图的连通分支数为2；
2. 判断两个点是否在同一连通块内；
3. 增加一条边后是否会产生环；
4. 用于求解最小生成树：Kruskal算法。

## 时间复杂度分析

| 操作  | 未优化 | 带优化（路径压缩 + 按秩合并） |
| :---- | :----- | :---------------------------- |
| Find  | O(n)   | 接近 O(α(n))                  |
| Union | O(n)   | 接近 O(α(n))                  |

## 代码实现

### 基础版本

```java
public class DisjointSet {

    public int[] fa; // 存储每个结点的父结点
    public int count; // 连通分量数量

    /**
     * 初始化 fa[]
     */
    public DisjointSet(int n) {
        fa = new int[n];
        count = n;
        for (int i = 0; i < n; i++) {
            fa[i] = i; // 初始化，每个结点的父节点设为自己
        }
    }

    /**
     * find()函数，查询x的根节点
     */
    public int find(int x) {
        /*
        // 递归写法
        if (x == fa[x]) { // 自己就是代表元,父节点是本身
            return x;
        } else { // 否则一直找
            return find(fa[x]);
        }
         */
        while (x != fa[x]) { // 一层一层访问父节点，直到根节点（代表元）
            x = fa[x];
        }
        return x;
    }

    /**
     * union()函数，合并节点
     */
    public void union(int x, int y) {
        // 找到代表元
        x = find(x);
        y = find(y);
        if (x != y) { // 不相等，随便找一个结点当作代表元
            fa[x] = y;
        }
        count--;
    }

    /**
     * 判断两个结点是否连通
     */
    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }

    /**
     * 获取连通分量数量
     */
    public int count() {
        return count;
    }

    /**
     * 获取每个元素所属的集合（根节点）
     */
    public int[] getSets() {
        int[] sets = new int[fa.length];
        for (int i = 0; i < fa.length; i++) {
            sets[i] = find(i);
        }
        return sets;
    }

    public static void main(String[] args) {
        int n = 10;
        DisjointSet ds = new DisjointSet(n);
        ds.union(0, 1);
        ds.union(1, 2);
        ds.union(3, 4);
        ds.union(4, 5);
        ds.union(6, 7);
        ds.union(7, 8);
        ds.union(8, 9);
        // 2 -> 1 -> 0
        // 5 -> 4 -> 3
        // 9 -> 8 -> 7 -> 6
        System.out.println(ds.isConnected(0, 8)); // false
        System.out.println(ds.count()); // 3
        System.out.println(Arrays.toString(ds.getSets()));
        // [2, 2, 2, 5, 5, 5, 9, 9, 9, 9]
    }
}

```

### 优化版本（路径压缩 + 按秩合并）

```java
public class DisjointSetOptimize {

    public int[] fa; // 存储每个结点的父结点
    public int[] rank; // 树的秩
    public int count; // 连通分量数量

    /**
     * 初始化 fa[], rank[]
     */
    public DisjointSetOptimize(int n) {
        fa = new int[n];
        rank = new int[n];
        count = n;
        for (int i = 0; i < n; i++) {
            fa[i] = i; // 初始化，每个结点的父节点设为自己
            rank[i] = 1; // 初始化，每个结点构成树，秩为1
        }
    }

    /**
     * 路径压缩：优化Find
     * 把沿途的每个节点的父节点都设为根节点
     */
    public int find(int x) {
        if (x == fa[x]) {
            return x;
        } else {
            fa[x] = find(fa[x]);
            return fa[x];
        }
    }

    /**
     * 按秩合并：优化Union
     * 总是将较小的树合并到较大的树上
     */
    public void union(int x, int y) {
        // 找到代表元
        x = find(x);
        y = find(y);
        if (x == y) { // 在同一个集合内
            return;
        }
        if (rank[x] > rank[y]) {
            fa[y] = x; // x为y的父节点
        } else {
            if (rank[x] == rank[y]) { // 如果高度相等，y的高度+1
                rank[y]++;
            }
            fa[x] = y; // y为x的父节点
        }
        count--;
    }

    /**
     * 判断两个结点是否连通
     */
    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }

    /**
     * 获取连通分量数量
     */
    public int count() {
        return count;
    }

    /**
     * 获取每个元素所属的集合（根节点）
     */
    public int[] getSets() {
        int[] sets = new int[fa.length];
        for (int i = 0; i < fa.length; i++) {
            sets[i] = find(i);
        }
        return sets;
    }

    public static void main(String[] args) {
        int n = 10;
        DisjointSetOptimize ds = new DisjointSetOptimize(n);
        ds.union(0, 1);
        ds.union(1, 2);
        ds.union(3, 4);
        ds.union(4, 5);
        ds.union(6, 7);
        ds.union(7, 8);
        ds.union(8, 9);
        // 1 -> 0, 1 -> 2
        // 4 -> 3, 4 -> 5
        // 7 -> 6, 7 -> 8, 7 -> 9
        System.out.println(ds.isConnected(0, 8)); // fasle
        System.out.println(ds.count()); // 3
        System.out.println(Arrays.toString(ds.getSets()));
        // [1, 1, 1, 4, 4, 4, 7, 7, 7, 7]
    }
}

```

注意，每个元素所属的集合（根节点）和基础版本不一样，**按秩合并优化后，**树的高度变小了。

### 朋友圈问题（连通分量）

count 初始值为节点个数，每次union，count--，最后的count值为连通分量个数。****

```java
public class FriendsNetwork {
    public static void main(String[] args) {
        // 创建并查集，表示10个人
        OptimizedUnionFind uf = new OptimizedUnionFind(10);
        
        // 建立朋友关系
        uf.union(0, 1);  // 0和1是朋友
        uf.union(1, 2);  // 1和2是朋友
        uf.union(3, 4);  // 3和4是朋友
        uf.union(4, 5);  // 4和5是朋友
        uf.union(2, 3);  // 2和3是朋友，这将连接两个朋友圈
        
        // 查询关系
        System.out.println("0和5是否在同一朋友圈: " + uf.isConnected(0, 5));  // true
        System.out.println("0和6是否在同一朋友圈: " + uf.isConnected(0, 6));  // false
        
        // 查看所有集合
        int[] sets = uf.getSets();
        System.out.println("每个人所属的朋友圈:");
        for (int i = 0; i < sets.length; i++) {
            System.out.println("Person " + i + " -> Group " + sets[i]);
        }
        
        System.out.println("朋友圈总数: " + uf.count());
    }
}
```

