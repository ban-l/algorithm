# 前缀和，差分

## 前缀和

- l 和 r 为 序号， l 到 r 区间的和：`sum[r] - sum[l-1]`，[]中值为序号
- l 和 r 为 下标， l 到 r 区间的和：`sum[r+1] - sum[l]`，[]中值为序号

示例：

1. 数组为 nums = [1, 2, 3, 4, 5]
2. 前缀和为 sum = [1, 3, 6, 10, 15]
3. 序号 2 到 4 区间的和：sum[4] - sum[2-1] = 10 - 1 = 9
4. 下表 1 到 3 区间的和：sum[3+1] - sum[1] = 10 - 1 = 9

## 差分

差分解决的问题

- 存在一个序列，对序列某些不确定的区间多次进行加/减操作时，即序列某一特定范围内的所有值都加/减一个常数；
- 如果每次都是对这些区间遍历操作，假设进行n次操作，每次对长度为m的数组进行操作，时间复杂度为O(nm)；
- 如果使用差分来解决，可以将时间复杂度变为O(n)。

## 前缀和 与 差分

**差分可以简单的看成序列中每个元素与其前一个元素的差。**

**原序列为差分序列的前缀和**。

注意：差分只能够解决加减的问题，不能够解决乘除的问题。

## 区间加

区间 `[l,r]` 中的所有值都加上常数`c`

- `b[l] += c;`
- `b[r+1] -= c;`

## 区间减

区间`[l,r]`中的所有值都减去常数`c`

- `b[l] -= c;`
- `b[r+1] += c;`

## 差分解题步骤

1. 构造差分数组
2. 进行相应的加减操作
3. 差分还原（前缀和）

## 代码实现

```java
public class Difference {

    /**
     * 1.构造差分数组
     * 2.进行加减操作
     * 3.差分还原(前缀和)
     * <p>
     * 区间[l,r]中的所有值都 加上 常数c
     * b[l] += c;
     * b[r+1] -= c;
     * <p>
     * 区间[l,r]中的所有值都 减去 常数c
     * b[l] -= c;
     * b[r+1] += c;
     */
    private int[] diff; // 差分数组

    /* 1.输入一个初始数组，构造差分数组 */
    public Difference(int[] nums) {
        diff = new int[nums.length];
        diff[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            diff[i] = nums[i] - nums[i - 1];
        }
    }

    /* 2.给闭区间 [i, j] 增加 val（可以是负数）*/
    public void increment(int i, int j, int val) {
        diff[i] += val;
        if (j + 1 < diff.length) {
            diff[j + 1] -= val; // 边界处理
        }
    }

    /* 2.给闭区间 [i, j] 减去 val（可以是负数）*/
    public void decrement(int i, int j, int val) {
        diff[i] -= val;
        if (j + 1 < diff.length) { // 边界处理
            diff[j + 1] += val;
        }
    }

    /* 3.差分还原(前缀和) */
    public int[] result() {
        int[] res = new int[diff.length];
        // 根据 差分数组 还原 结果数组
        res[0] = diff[0];
        for (int i = 1; i < diff.length; i++) {
            res[i] = res[i - 1] + diff[i];
        }
        return res;
    }

    public static void main(String[] args) {
        int[] res = null;
        int[] nums = new int[]{4, 5, 3, 9, 8};
        System.out.println(Arrays.toString(nums));
        Difference d = new Difference(nums);
        d.increment(1, 2, 2);
        res = d.result();
        System.out.println(Arrays.toString(res)); // [4, 7, 5, 9, 8]
        d.decrement(1, 2, 2);
        res = d.result();
        System.out.println(Arrays.toString(res)); // [4, 5, 3, 9, 8]
    }

}
```

## 题目

```java
/**
 * 车上最初有 capacity 个空座位。车只能向一个方向行驶（也就是说，不允许掉头或改变方向）
 * <p>
 * 给定整数 capacity 和一个数组 trips，trip[i] = [numPassengersi, fromi, toi]
 * 表示第 i 次旅行有 numPassengersi 乘客，接他们和放他们的位置分别是 fromi 和 toi，这些位置是从汽车的初始位置向东的公里数。
 * <p>
 * 当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false。
 *
 * @param trips    上下车人数及地点
 * @param capacity 载重量限制
 */
public boolean carPooling(int[][] trips, int capacity) {
    // 1.找到最远的站点(获取最大长度)
    int toMax = 0;
    for (int[] trip : trips) {
        toMax = Math.max(toMax, trip[2]);
    }
    // 2.差分数组(maxLength为下标，所以数组长度+1)
    int[] diff = new int[toMax + 1];
    for (int[] trip : trips) {
        // 3.区间内加减
        int passengers = trip[0];
        int from = trip[1];
        int to = trip[2];
        // 在from位置上车，增加人数
        diff[from] += passengers;
        // 在to位置下车，减少人数
        // 注意：乘客在to位置下车，所以这个位置就不在车上了
        diff[to] -= passengers;
    }
    // 4.计算前缀和，检查容量
    int currentPassengers = 0;
    for (int i = 0; i < diff.length; i++) {
        currentPassengers += diff[i];
        if (currentPassengers > capacity) {
            return false;
        }
    }
    return true;
}
```

### 问题背景

- `trips[i][2]`表示乘客下车的位置（toi）
- 在上述问题，我们需要对`[from, to)`这个区间进行操作（左闭右开）
- 但是差分数组的操作是基于闭区间`[l, r]`的

### 为什么没有to+1，直接使用to

1. **区间含义不同**
   - 题目中的`to`位置是**不包含**的，即乘客在该位置已经下车；
   - 差分数组操作`increment(i, j, val)`是对闭区间`[i, j]`进行操作。

2. **实际影响范围**
   ```java
   // 例如：trip = [2, 1, 5] 表示2个乘客从位置1上车，在位置5下车
   // 实际乘坐区间是 [1, 2, 3, 4]，位置5已经下车了
   // 所以需要操作的区间是 [1, 4]，即 [from, to-1]
   ```


3. **差分操作原理**
   - 对于区间`[l, r]`加上`val`，我们执行：
     - `diff[l] += val`
     - `diff[r+1] -= val`
   - 如果我们要对`[from, to-1]`区间操作，就需要：
     - `diff[from] += val`
     - `diff[(to-1)+1] -= val` 即 `diff[to] -= val`

因此，直接使用`to`为了正确地将左闭右开区间`[from, to)`转换为闭区间`[from, to-1]`来进行差分数组操作。