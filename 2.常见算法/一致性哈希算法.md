# ä¸€è‡´æ€§å“ˆå¸Œç®—æ³•

## 1. èƒŒæ™¯ä¸é—®é¢˜

### ä¼ ç»Ÿå“ˆå¸Œçš„é—®é¢˜

åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œä¼ ç»Ÿçš„å“ˆå¸Œåˆ†ç‰‡æ–¹å¼æ˜¯ï¼š`hash(key) % N`ï¼ˆNä¸ºæœåŠ¡å™¨æ•°é‡ï¼‰

**é—®é¢˜**ï¼šå½“æœåŠ¡å™¨æ•°é‡å˜åŒ–æ—¶ï¼Œå‡ ä¹æ‰€æœ‰æ•°æ®çš„æ˜ å°„å…³ç³»éƒ½ä¼šæ”¹å˜ï¼Œå¯¼è‡´å¤§é‡æ•°æ®é‡æ–°åˆ†å¸ƒï¼Œè¿™åœ¨åˆ†å¸ƒå¼ç¼“å­˜ä¸­æ˜¯ç¾éš¾æ€§çš„ã€‚

### ä¸¾ä¾‹è¯´æ˜

å‡è®¾æœ‰3å°æœåŠ¡å™¨ï¼Œkey="user123"ï¼š

- åˆå§‹ï¼š`hash("user123") % 3 = 1`ï¼Œæ•°æ®åœ¨æœåŠ¡å™¨1
- å¢åŠ 1å°æœåŠ¡å™¨ï¼š`hash("user123") % 4 = 2`ï¼Œæ•°æ®éœ€è¿ç§»åˆ°æœåŠ¡å™¨2
- å¤±æ•ˆç‡é«˜è¾¾75%ï¼

## 2. ä¸€è‡´æ€§å“ˆå¸ŒåŸç†

### æ ¸å¿ƒæ€æƒ³

å°†å“ˆå¸Œç©ºé—´ç»„ç»‡æˆä¸€ä¸ªè™šæ‹Ÿçš„åœ†ç¯ï¼ˆHash Ringï¼‰ï¼Œè€Œä¸æ˜¯çº¿æ€§ç©ºé—´ã€‚

### åŸºæœ¬æ­¥éª¤

1. **æ„å»ºå“ˆå¸Œç¯**ï¼šå°†å“ˆå¸Œå€¼ç©ºé—´[0, 2^32-1]é¦–å°¾ç›¸æ¥å½¢æˆåœ†ç¯
2. **æœåŠ¡å™¨æ˜ å°„**ï¼šå°†æ¯å°æœåŠ¡å™¨é€šè¿‡å“ˆå¸Œå‡½æ•°æ˜ å°„åˆ°ç¯ä¸Šçš„æŸä¸ªç‚¹
3. **æ•°æ®æ˜ å°„**ï¼šå°†æ•°æ®keyé€šè¿‡å“ˆå¸Œå‡½æ•°æ˜ å°„åˆ°ç¯ä¸Š
4. **æŸ¥æ‰¾è§„åˆ™**ï¼šæ²¿é¡ºæ—¶é’ˆæ–¹å‘æ‰¾åˆ°ç¬¬ä¸€å°æœåŠ¡å™¨## 3. è™šæ‹ŸèŠ‚ç‚¹ï¼ˆVirtual Nodesï¼‰

### é—®é¢˜

ä»…ä½¿ç”¨ç‰©ç†èŠ‚ç‚¹å¯èƒ½å¯¼è‡´æ•°æ®åˆ†å¸ƒä¸å‡åŒ€ï¼Œç‰¹åˆ«æ˜¯èŠ‚ç‚¹è¾ƒå°‘æ—¶ã€‚

### è§£å†³æ–¹æ¡ˆ

ä¸ºæ¯ä¸ªç‰©ç†èŠ‚ç‚¹åˆ›å»ºå¤šä¸ªè™šæ‹ŸèŠ‚ç‚¹ï¼Œåˆ†å¸ƒåœ¨ç¯çš„ä¸åŒä½ç½®ã€‚

### å®ç°æ–¹å¼

```python
# ä¸ºæœåŠ¡å™¨server1åˆ›å»ºè™šæ‹ŸèŠ‚ç‚¹
for i in range(virtual_nodes_count):
    virtual_name = f"server1#{i}"
    hash_value = hash(virtual_name) % (2**32)
    # å°†è™šæ‹ŸèŠ‚ç‚¹æ·»åŠ åˆ°ç¯ä¸Š
```

## 4. ç®—æ³•ä¼˜åŠ¿

### 1. æœ€å°åŒ–æ•°æ®è¿ç§»

- æ·»åŠ èŠ‚ç‚¹ï¼šåªå½±å“ä¸€ä¸ªåŒºé—´çš„æ•°æ®
- åˆ é™¤èŠ‚ç‚¹ï¼šåªéœ€è¿ç§»è¯¥èŠ‚ç‚¹çš„æ•°æ®åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
- å¹³å‡åªéœ€è¿ç§» K/N çš„æ•°æ®ï¼ˆKä¸ºæ€»æ•°æ®ï¼ŒNä¸ºèŠ‚ç‚¹æ•°ï¼‰

### 2. è´Ÿè½½å‡è¡¡

- è™šæ‹ŸèŠ‚ç‚¹ç¡®ä¿æ•°æ®åˆ†å¸ƒå‡åŒ€
- å¯ä»¥æ ¹æ®æœåŠ¡å™¨æ€§èƒ½è®¾ç½®ä¸åŒæ•°é‡çš„è™šæ‹ŸèŠ‚ç‚¹

### 3. å®¹é”™æ€§

- å•ä¸ªèŠ‚ç‚¹æ•…éšœåªå½±å“å±€éƒ¨æ•°æ®
- ç³»ç»Ÿå¯ä»¥ç»§ç»­æ­£å¸¸è¿è¡Œ

## 5. å®é™…åº”ç”¨åœºæ™¯

### åˆ†å¸ƒå¼ç¼“å­˜

- **Redis Cluster**ï¼šä½¿ç”¨ä¸€è‡´æ€§å“ˆå¸Œåˆ†ç‰‡
- **Memcached**ï¼šå®¢æˆ·ç«¯å®ç°ä¸€è‡´æ€§å“ˆå¸Œ
- **Amazon DynamoDB**ï¼šå†…éƒ¨ä½¿ç”¨ç±»ä¼¼æœºåˆ¶

### åˆ†å¸ƒå¼å­˜å‚¨

- **Cassandra**ï¼šä½¿ç”¨ä¸€è‡´æ€§å“ˆå¸Œè¿›è¡Œæ•°æ®åˆ†åŒº
- **Amazon S3**ï¼šå†…éƒ¨åˆ†åŒºæœºåˆ¶
- **Ceph**ï¼šCRUSHç®—æ³•åŸºäºä¸€è‡´æ€§å“ˆå¸Œ

### CDNå†…å®¹åˆ†å‘

- æ ¹æ®ç”¨æˆ·åœ°ç†ä½ç½®å’Œå†…å®¹å“ˆå¸Œåˆ†é…è¾¹ç¼˜èŠ‚ç‚¹

### å¾®æœåŠ¡è´Ÿè½½å‡è¡¡

- æœåŠ¡å®ä¾‹çš„åŠ¨æ€æ‰©ç¼©å®¹
- ä¿æŒå®¢æˆ·ç«¯ä¼šè¯äº²å’Œæ€§

## 6. ç®—æ³•å±€é™æ€§

### 1. æ•°æ®çƒ­ç‚¹

- æŸäº›keyè®¿é—®é¢‘ç‡å¾ˆé«˜æ—¶ï¼Œä»å¯èƒ½é€ æˆè´Ÿè½½ä¸å‡

### 2. èŒƒå›´æŸ¥è¯¢å›°éš¾

- ä¸æ”¯æŒæŒ‰keyèŒƒå›´è¿›è¡ŒæŸ¥è¯¢æ“ä½œ

### 3. å®ç°å¤æ‚åº¦

- ç›¸æ¯”ç®€å•å“ˆå¸Œï¼Œå®ç°å’Œç»´æŠ¤æ›´å¤æ‚

### 4. å…ƒæ•°æ®å¼€é”€

- éœ€è¦ç»´æŠ¤ç¯çš„çŠ¶æ€ä¿¡æ¯

## 7. ä¼˜åŒ–ç­–ç•¥

### 1. æœ‰ç•Œè´Ÿè½½ä¸€è‡´æ€§å“ˆå¸Œ

é™åˆ¶å•ä¸ªèŠ‚ç‚¹çš„æœ€å¤§è´Ÿè½½ï¼Œè¶…è¿‡é˜ˆå€¼æ—¶é‡æ–°åˆ†é…

### 2. åŠ æƒä¸€è‡´æ€§å“ˆå¸Œ

æ ¹æ®æœåŠ¡å™¨æ€§èƒ½åˆ†é…ä¸åŒæ•°é‡çš„è™šæ‹ŸèŠ‚ç‚¹

### 3. åŠ¨æ€è™šæ‹ŸèŠ‚ç‚¹è°ƒæ•´

æ ¹æ®å®é™…è´Ÿè½½æƒ…å†µåŠ¨æ€å¢å‡è™šæ‹ŸèŠ‚ç‚¹

## 8. ä»£ç å®ç°

```java
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;

/**
 * @author: lubanban1
 * @date: 2025/9/4 10:28
 * @description: <p>
 *
 */

public class ConsistentHash<T> {
    // å“ˆå¸Œå‡½æ•°ï¼Œç”¨äºè®¡ç®—èŠ‚ç‚¹å’Œé”®çš„å“ˆå¸Œå€¼
    private final HashFunction hashFunction;

    // æ¯ä¸ªçœŸå®èŠ‚ç‚¹å¯¹åº”çš„è™šæ‹ŸèŠ‚ç‚¹æ•°é‡
    private final int numberOfReplicas;

    // å“ˆå¸Œç¯ï¼Œä½¿ç”¨TreeMapå®ç°æœ‰åºçš„å“ˆå¸Œç¯
    private final TreeMap<Long, T> circle = new TreeMap<>();

    // çœŸå®èŠ‚ç‚¹åˆ°è™šæ‹ŸèŠ‚ç‚¹æ˜ å°„çš„ç¼“å­˜
    private final Map<T, List<Long>> nodeToReplicas = new HashMap<>();

    /**
     * é»˜è®¤æ„é€ å‡½æ•°ï¼Œä½¿ç”¨MD5å“ˆå¸Œï¼Œè™šæ‹ŸèŠ‚ç‚¹æ•°ä¸º160
     */
    public ConsistentHash() {
        this(new MD5Hash(), 160);
    }

    /**
     * æ„é€ å‡½æ•°
     *
     * @param hashFunction     å“ˆå¸Œå‡½æ•°
     * @param numberOfReplicas æ¯ä¸ªçœŸå®èŠ‚ç‚¹çš„è™šæ‹ŸèŠ‚ç‚¹æ•°
     */
    public ConsistentHash(HashFunction hashFunction, int numberOfReplicas) {
        this.hashFunction = hashFunction;
        this.numberOfReplicas = numberOfReplicas;
    }

    /**
     * æ·»åŠ èŠ‚ç‚¹åˆ°å“ˆå¸Œç¯
     *
     * @param node èŠ‚ç‚¹
     */
    public void add(T node) {
        // ä¸ºæ¯ä¸ªçœŸå®èŠ‚ç‚¹åˆ›å»ºè™šæ‹ŸèŠ‚ç‚¹
        List<Long> replicas = new ArrayList<>();
        for (int i = 0; i < numberOfReplicas; i++) {
            // è™šæ‹ŸèŠ‚ç‚¹åç§°æ ¼å¼: node#0, node#1, ...
            String virtualNodeName = node.toString() + "#" + i;
            long hash = hashFunction.hash(virtualNodeName);
            circle.put(hash, node);
            replicas.add(hash);
        }
        nodeToReplicas.put(node, replicas);
    }

    /**
     * ä»å“ˆå¸Œç¯ä¸­ç§»é™¤èŠ‚ç‚¹
     *
     * @param node èŠ‚ç‚¹
     */
    public void remove(T node) {
        List<Long> replicas = nodeToReplicas.remove(node);
        if (replicas != null) {
            for (Long hash : replicas) {
                circle.remove(hash);
            }
        }
    }

    /**
     * æ ¹æ®é”®è·å–å¯¹åº”çš„èŠ‚ç‚¹
     *
     * @param key é”®
     * @return èŠ‚ç‚¹
     */
    public T get(Object key) {
        if (circle.isEmpty()) {
            return null;
        }
        long hash = hashFunction.hash(key.toString());

        // ä½¿ç”¨TreeMapçš„ceilingEntryæ–¹æ³•æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äºè¯¥å“ˆå¸Œå€¼çš„èŠ‚ç‚¹
        Map.Entry<Long, T> entry = circle.ceilingEntry(hash);

        // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œåˆ™ä½¿ç”¨ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆç¯çŠ¶ç»“æ„ï¼‰
        if (entry == null) {
            entry = circle.firstEntry();
        }

        return entry.getValue();
    }

    /**
     * è·å–å“ˆå¸Œç¯ä¸­çš„èŠ‚ç‚¹æ•°é‡ï¼ˆçœŸå®èŠ‚ç‚¹ï¼‰
     *
     * @return èŠ‚ç‚¹æ•°é‡
     */
    public int size() {
        return nodeToReplicas.size();
    }

    /**
     * è·å–æ‰€æœ‰çœŸå®èŠ‚ç‚¹
     *
     * @return æ‰€æœ‰çœŸå®èŠ‚ç‚¹
     */
    public Set<T> getNodes() {
        return new HashSet<>(nodeToReplicas.keySet());
    }

    /**
     * å“ˆå¸Œå‡½æ•°æ¥å£
     */
    public interface HashFunction {
        long hash(String key);
    }

    /**
     * åŸºäºMD5çš„å“ˆå¸Œå‡½æ•°å®ç°
     */
    public static class MD5Hash implements HashFunction {
        private final MessageDigest md5;

        public MD5Hash() {
            try {
                md5 = MessageDigest.getInstance("MD5");
            } catch (NoSuchAlgorithmException e) {
                throw new RuntimeException("MD5 not supported", e);
            }
        }

        @Override
        public long hash(String key) {
            md5.reset();
            md5.update(key.getBytes());
            byte[] digest = md5.digest();

            // å–MD5çš„å‰8å­—èŠ‚è½¬æ¢ä¸ºlongç±»å‹
            long h = 0;
            for (int i = 0; i < 8; i++) {
                h <<= 8;
                h |= (digest[i]) & 0xFF;
            }
            return h;
        }
    }

    /**
     * æµ‹è¯•æ–¹æ³•
     */
    public static void main(String[] args) {
        // åˆ›å»ºä¸€è‡´æ€§å“ˆå¸Œå®ä¾‹ï¼Œæ¯ä¸ªçœŸå®èŠ‚ç‚¹æœ‰3ä¸ªè™šæ‹ŸèŠ‚ç‚¹
        ConsistentHash<String> consistentHash = new ConsistentHash<>(new MD5Hash(), 3);

        // æ·»åŠ èŠ‚ç‚¹
        consistentHash.add("Node-A");
        consistentHash.add("Node-B");
        consistentHash.add("Node-C");

        // æµ‹è¯•é”®çš„åˆ†å¸ƒ
        Map<String, Integer> distribution = new HashMap<>();
        for (int i = 0; i < 10000; i++) {
            String key = "key-" + i;
            String node = consistentHash.get(key);
            distribution.put(node, distribution.getOrDefault(node, 0) + 1);
        }

        // æ‰“å°åˆ†å¸ƒæƒ…å†µ
        System.out.println("èŠ‚ç‚¹åˆ†å¸ƒæƒ…å†µ:");
        for (String node : distribution.keySet()) {
            System.out.println(node + ": " + distribution.get(node) + " keys");
        }

        // æ·»åŠ ä¸€ä¸ªæ–°èŠ‚ç‚¹å¹¶é‡æ–°æµ‹è¯•
        System.out.println("\næ·»åŠ æ–°èŠ‚ç‚¹ Node-D åçš„åˆ†å¸ƒ:");
        consistentHash.add("Node-D");

        distribution.clear();
        for (int i = 0; i < 10000; i++) {
            String key = "key-" + i;
            String node = consistentHash.get(key);
            distribution.put(node, distribution.getOrDefault(node, 0) + 1);
        }

        for (String node : distribution.keySet()) {
            System.out.println(node + ": " + distribution.get(node) + " keys");
        }

        // æµ‹è¯•èŠ‚ç‚¹ç§»é™¤
        System.out.println("\nç§»é™¤èŠ‚ç‚¹ Node-B åçš„åˆ†å¸ƒ:");
        consistentHash.remove("Node-B");

        distribution.clear();
        for (int i = 0; i < 10000; i++) {
            String key = "key-" + i;
            String node = consistentHash.get(key);
            distribution.put(node, distribution.getOrDefault(node, 0) + 1);
        }

        for (String node : distribution.keySet()) {
            System.out.println(node + ": " + distribution.get(node) + " keys");
        }
    }

}
```

## 9. å¯è§†åŒ–

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸€è‡´æ€§å“ˆå¸Œç®—æ³•æ¼”ç¤º</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        .demo-section {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .controls {
            flex: 1;
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        }
        
        .visualization {
            flex: 2;
            text-align: center;
            position: relative;
        }
        
        canvas {
            border: 3px solid #3498db;
            border-radius: 15px;
            background: #fff;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #2c3e50;
        }
        
        input, button {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
        }
        
        button {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }
        
        .server-list, .key-list {
            margin-top: 20px;
            padding: 15px;
            background: white;
            border-radius: 10px;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .server-item, .key-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: #ecf0f1;
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .server-item:hover, .key-item:hover {
            background: #d5dbdb;
            transform: translateX(5px);
        }
        
        .remove-btn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            width: auto;
        }
        
        .remove-btn:hover {
            transform: scale(1.1);
        }
        
        .stats {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
            border-radius: 10px;
            text-align: center;
        }
        
        .stats h3 {
            margin: 0 0 10px 0;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 20px;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid #fff;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”„ ä¸€è‡´æ€§å“ˆå¸Œç®—æ³•å¯è§†åŒ–æ¼”ç¤º</h1>
        
        <div class="demo-section">
            <div class="controls">
                <div class="control-group">
                    <label>æ·»åŠ æœåŠ¡å™¨:</label>
                    <input type="text" id="serverInput" placeholder="è¾“å…¥æœåŠ¡å™¨åç§° (å¦‚: Server1)" />
                    <button onclick="addServer()">â• æ·»åŠ æœåŠ¡å™¨</button>
                </div>
                
                <div class="control-group">
                    <label>æ·»åŠ æ•°æ®Key:</label>
                    <input type="text" id="keyInput" placeholder="è¾“å…¥æ•°æ®key (å¦‚: user123)" />
                    <button onclick="addKey()">ğŸ”‘ æ·»åŠ Key</button>
                </div>
                
                <div class="control-group">
                    <button onclick="clearAll()" style="background: linear-gradient(135deg, #95a5a6, #7f8c8d);">ğŸ—‘ï¸ æ¸…ç©ºæ‰€æœ‰</button>
                </div>
                
                <div class="server-list">
                    <h3>ğŸ–¥ï¸ æœåŠ¡å™¨åˆ—è¡¨</h3>
                    <div id="serverList"></div>
                </div>
                
                <div class="key-list">
                    <h3>ğŸ”‘ æ•°æ®Keys</h3>
                    <div id="keyList"></div>
                </div>
            </div>
            
            <div class="visualization">
                <canvas id="hashRing" width="500" height="500"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e74c3c;"></div>
                        <span>æœåŠ¡å™¨</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3498db;"></div>
                        <span>æ•°æ®Key</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2ecc71;"></div>
                        <span>è™šæ‹ŸèŠ‚ç‚¹</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="stats">
            <h3>ğŸ“Š åˆ†å¸ƒç»Ÿè®¡</h3>
            <div id="distributionStats"></div>
        </div>
    </div>

    <script>
        class ConsistentHashing {
            constructor() {
                this.servers = new Map();
                this.keys = new Map();
                this.virtualNodes = 3; // æ¯ä¸ªæœåŠ¡å™¨çš„è™šæ‹ŸèŠ‚ç‚¹æ•°
                this.canvas = document.getElementById('hashRing');
                this.ctx = this.canvas.getContext('2d');
                this.centerX = 250;
                this.centerY = 250;
                this.radius = 200;
            }
            
            // ç®€å•çš„å“ˆå¸Œå‡½æ•°
            hash(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
                }
                return Math.abs(hash) % 360; // æ˜ å°„åˆ°0-360åº¦
            }
            
            addServer(name) {
                if (this.servers.has(name)) return false;
                
                const positions = [];
                for (let i = 0; i < this.virtualNodes; i++) {
                    const virtualName = `${name}#${i}`;
                    const position = this.hash(virtualName);
                    positions.push(position);
                }
                
                this.servers.set(name, positions);
                this.redistributeKeys();
                return true;
            }
            
            removeServer(name) {
                if (!this.servers.has(name)) return false;
                this.servers.delete(name);
                this.redistributeKeys();
                return true;
            }
            
            addKey(key) {
                if (this.keys.has(key)) return false;
                const position = this.hash(key);
                const server = this.findServer(position);
                this.keys.set(key, { position, server });
                return true;
            }
            
            removeKey(key) {
                return this.keys.delete(key);
            }
            
            findServer(keyPosition) {
                if (this.servers.size === 0) return null;
                
                let minDistance = Infinity;
                let closestServer = null;
                
                for (let [serverName, positions] of this.servers) {
                    for (let pos of positions) {
                        let distance = (pos - keyPosition + 360) % 360;
                        if (distance === 0) distance = 360;
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestServer = serverName;
                        }
                    }
                }
                
                return closestServer;
            }
            
            redistributeKeys() {
                for (let [key, data] of this.keys) {
                    const server = this.findServer(data.position);
                    this.keys.set(key, { ...data, server });
                }
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ç»˜åˆ¶å“ˆå¸Œç¯
                this.ctx.beginPath();
                this.ctx.arc(this.centerX, this.centerY, this.radius, 0, 2 * Math.PI);
                this.ctx.strokeStyle = '#bdc3c7';
                this.ctx.lineWidth = 3;
                this.ctx.stroke();
                
                // ç»˜åˆ¶è§’åº¦æ ‡è®°
                this.ctx.font = '12px Arial';
                this.ctx.fillStyle = '#7f8c8d';
                this.ctx.textAlign = 'center';
                for (let angle = 0; angle < 360; angle += 90) {
                    const x = this.centerX + (this.radius + 20) * Math.cos((angle - 90) * Math.PI / 180);
                    const y = this.centerY + (this.radius + 20) * Math.sin((angle - 90) * Math.PI / 180);
                    this.ctx.fillText(angle + 'Â°', x, y);
                }
                
                // ç»˜åˆ¶æœåŠ¡å™¨èŠ‚ç‚¹
                for (let [serverName, positions] of this.servers) {
                    positions.forEach((pos, index) => {
                        const x = this.centerX + this.radius * Math.cos((pos - 90) * Math.PI / 180);
                        const y = this.centerY + this.radius * Math.sin((pos - 90) * Math.PI / 180);
                        
                        // è™šæ‹ŸèŠ‚ç‚¹ç”¨å°åœ†åœˆè¡¨ç¤º
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, index === 0 ? 12 : 8, 0, 2 * Math.PI);
                        this.ctx.fillStyle = index === 0 ? '#e74c3c' : '#2ecc71';
                        this.ctx.fill();
                        this.ctx.strokeStyle = '#fff';
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                        
                        // æ ‡ç­¾
                        if (index === 0) {
                            this.ctx.fillStyle = '#2c3e50';
                            this.ctx.font = 'bold 12px Arial';
                            this.ctx.textAlign = 'center';
                            this.ctx.fillText(serverName, x, y - 20);
                        }
                    });
                }
                
                // ç»˜åˆ¶æ•°æ®keys
                for (let [key, data] of this.keys) {
                    const x = this.centerX + this.radius * Math.cos((data.position - 90) * Math.PI / 180);
                    const y = this.centerY + this.radius * Math.sin((data.position - 90) * Math.PI / 180);
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 8, 0, 2 * Math.PI);
                    this.ctx.fillStyle = '#3498db';
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                    
                    // Keyæ ‡ç­¾
                    this.ctx.fillStyle = '#2c3e50';
                    this.ctx.font = '10px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(key, x, y + 20);
                    
                    // ç»˜åˆ¶åˆ°æœåŠ¡å™¨çš„è¿çº¿
                    if (data.server && this.servers.has(data.server)) {
                        const serverPositions = this.servers.get(data.server);
                        const serverPos = serverPositions[0]; // ä¸»èŠ‚ç‚¹ä½ç½®
                        const serverX = this.centerX + this.radius * Math.cos((serverPos - 90) * Math.PI / 180);
                        const serverY = this.centerY + this.radius * Math.sin((serverPos - 90) * Math.PI / 180);
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, y);
                        this.ctx.lineTo(serverX, serverY);
                        this.ctx.strokeStyle = '#f39c12';
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                    }
                }
            }
            
            getDistributionStats() {
                const distribution = new Map();
                for (let [serverName] of this.servers) {
                    distribution.set(serverName, 0);
                }
                
                for (let [key, data] of this.keys) {
                    if (data.server) {
                        distribution.set(data.server, (distribution.get(data.server) || 0) + 1);
                    }
                }
                
                return distribution;
            }
        }
        
        const hashRing = new ConsistentHashing();
        
        // åˆå§‹åŒ–ä¸€äº›ç¤ºä¾‹æ•°æ®
        hashRing.addServer('Server-A');
        hashRing.addServer('Server-B');
        hashRing.addServer('Server-C');
        hashRing.addKey('user123');
        hashRing.addKey('data456');
        hashRing.addKey('cache789');
        
        function updateDisplay() {
            updateServerList();
            updateKeyList();
            updateStats();
            hashRing.draw();
        }
        
        function addServer() {
            const input = document.getElementById('serverInput');
            const serverName = input.value.trim();
            if (serverName && hashRing.addServer(serverName)) {
                input.value = '';
                updateDisplay();
            }
        }
        
        function removeServer(name) {
            hashRing.removeServer(name);
            updateDisplay();
        }
        
        function addKey() {
            const input = document.getElementById('keyInput');
            const key = input.value.trim();
            if (key && hashRing.addKey(key)) {
                input.value = '';
                updateDisplay();
            }
        }
        
        function removeKey(key) {
            hashRing.removeKey(key);
            updateDisplay();
        }
        
        function clearAll() {
            hashRing.servers.clear();
            hashRing.keys.clear();
            updateDisplay();
        }
        
        function updateServerList() {
            const list = document.getElementById('serverList');
            list.innerHTML = '';
            for (let [serverName, positions] of hashRing.servers) {
                const item = document.createElement('div');
                item.className = 'server-item';
                item.innerHTML = `
                    <span>${serverName} (${positions[0]}Â°)</span>
                    <button class="remove-btn" onclick="removeServer('${serverName}')">åˆ é™¤</button>
                `;
                list.appendChild(item);
            }
        }
        
        function updateKeyList() {
            const list = document.getElementById('keyList');
            list.innerHTML = '';
            for (let [key, data] of hashRing.keys) {
                const item = document.createElement('div');
                item.className = 'key-item';
                item.innerHTML = `
                    <span>${key} â†’ ${data.server || 'None'}</span>
                    <button class="remove-btn" onclick="removeKey('${key}')">åˆ é™¤</button>
                `;
                list.appendChild(item);
            }
        }
        
        function updateStats() {
            const stats = hashRing.getDistributionStats();
            const statsDiv = document.getElementById('distributionStats');
            let html = '';
            
            for (let [server, count] of stats) {
                const percentage = hashRing.keys.size > 0 ? (count / hashRing.keys.size * 100).toFixed(1) : 0;
                html += `<div>${server}: ${count}ä¸ªKey (${percentage}%)</div>`;
            }
            
            if (html === '') {
                html = '<div>æš‚æ— æ•°æ®</div>';
            }
            
            statsDiv.innerHTML = html;
        }
        
        // é”®ç›˜äº‹ä»¶å¤„ç†
        document.getElementById('serverInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') addServer();
        });
        
        document.getElementById('keyInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') addKey();
        });
        
        // åˆå§‹åŒ–æ˜¾ç¤º
        updateDisplay();
    </script>
</body>
</html>
```

![image-20250908100805482](assets/image-20250908100805482.png)
