# 同时寻找缺失和重复的元素

## 例题1：错误的集合

### 题目描述

```text
集合 s 包含从 1 到 n 的整数。
不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。
给定一个数组 nums 代表了集合 S 发生错误后的结果。
请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。
```

### 示例 1：

输入：nums = [1,2,2,4]

输出：[2,3]

### 示例 2：

输入：nums = [1,1]

输出：[1,2]

## 解法1：哈希表

```java
public int[] findErrorNums(int[] nums) {
    int n = nums.length;
    // map统计次数
    HashMap<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < n; i++) {
        map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
    }
    int dup = 0, mis = 0;
    // 整数：1 到 n
    for (int i = 1; i <= n; i++) {
        int count = map.getOrDefault(i, 0);
        if (count == 2) { // 出现了两次
            dup = i;
        } else if (count == 0) {  // 没有出现
            mis = i;
        }
    }
    return new int[]{dup, mis};
}
```

## 解法2：不使用辅助空间

- 值减 1，将值和索引对应起来。
- 遍历数组，如果有一个值重复了：
  - 会导致有两个值对应到同一个索引；
  - 会导致有一个索引没有值对应。

```java
public int[] findErrorNums(int[] nums) {
    int n = nums.length;
    int dup = -1;
    for (int i = 0; i < n; i++) {
        // 值作为索引，索引从 0 开始,  值从 1 开始，所以值减 1
        int index = Math.abs(nums[i]) - 1;
        if (nums[index] > 0) {
            // 遍历后，将索引对应的值变负数
            nums[index] *= -1;
        } else {
            // 值为负数，说明重复
            dup = Math.abs(nums[i]);
        }
    }
    int missing = -1;
    for (int i = 0; i < n; i++) {
        // 值大于0，说明丢失
        if (nums[i] > 0) {
            // 将索引转换成元素
            missing = i + 1;
        }
    }
    return new int[]{dup, missing};
}
```

