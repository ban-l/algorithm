# 常用技巧

## 取整符号

- 向下取整：小于等于x的最大整数，⌊ x ⌋。
- 向上取整：大于等于x的最小整数，⌈ x ⌉。
- 四舍五入：最接近x的整数。

## 知识点

- 题目要求的测试用例，注意范围，范围较大的使用 `long`。
- 栈使用`LinkedList`或者`ArrayDeque`效率更高。
- 有序表的查找：二分搜索。
- 数组排序工具类：`Arrays.sort(int[] arr);`
- 集合排序工具类：`Collections.sort(List<T> list);`
- 图的存储：
  - 邻接矩阵：二维数组
  - 邻接表：数组+链表
- **图的遍历：深度优先搜索法、广度优先搜索法**。
- `Math.abs(n)`：取绝对值 。
- `Math.sqrt(n)`：返回一个正平方根。
- 集合删除，删除后list已改变。
  - 删除前两个节点，执行两次remove：`list.remove(0)`，`list.remove(0)`。
- `TreeSet`，有序，无重复，默认升序排列，`descendingSet()`可降序排列。两种排序方式：
  1. 集合存放的元素实现排序接口。
  2. 传入一个比较器参数。

## 分治法(分解、解决、合并)

对于一个规模为的 n  问题:

- 若该问题可以容易地解决（比如规模 n 较小）则直接解决；
- 否则将其分解为 k 个规模较小的子问题（分解）；

- 这些子问题互相独立且与原问题形式相同，**递归**地解这些子问题（解决）；
- 然后将各子问题的解合并得到原问题的解（合并）。

常用方法：递归、二分查找。

## 贪心算法

所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。

## 矩阵乘法

0次幂就是单位矩阵，m次幂，每次乘以原矩阵（m-1次）。

矩阵乘法需要三个矩阵

1. **原始矩阵**
2. **结果矩阵**
3. **记录矩阵**（临时矩阵，存储矩阵的中间状态，计算后需要初始化为0）

```java
int[][] original = new int[n][n];
int[][] result = new int[n][n];
int[][] temporary = new int[n][n];
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        int k = 0;
        while (k < n) {
            // 阶乘计算，temporary记录中间状态
            temporary[i][j] = result[i][k] * original[k][j];
            k++;
        }
        result = temporary;
        temporary = null;
    }
}
```



## 求一个数是2的几次幂

- 短除法（10->2）
- 掩码技术
- n&(n-1)消去二进制最后一个1

## 数学相关

1既不属于质数也不属于合数。

### 质数（又称素数）

是指在大于1的整数中，除了能被1和本身整除外，不能被其它数整除的数。

### 合数

是指在大于1的整数中，除了能被1和本身整除外，还能被其它数（0除外）整除的数，最小的合数是4，与之相对的是质数。

- 合数都可分解为质因数相乘。

### 约数‌（又称因数）

- 指整数a能被整数b（b≠0）整除时，b称为a的**约数**，a称为b的**倍数**。
- 示例：6的约数为1、2、3、6，因为6分别能被这些数整除。‌
- 一个数的约数必然包括1及其本身。

### 最大公约数（GCD）

- 能同时整除多个整数的最大正整数。
- 示例：12和18的公约数为1、2、3、6，其中最大的是6，因此GCD(12,18)=6。
- **最大公约数**‌与‌**最大公因数**‌为同一概念的不同表述，无本质区别。
- 与最小公倍数（LCM）存在关系：`gcd(a,b) × lcm(a,b) = a×b`

**‌计算方法**

1. ‌**质因数分解法**‌：
   - 将各数分解为质因数（如24=2³×3¹，36=2²×3²），取所有公共质因数的最小幂次相乘（2²×3¹=12）。
2. ‌**辗转相除法（欧几里得算法）**‌：
   - 用较大数除以较小数，将余数替换较大数，重复直至余数为0，最后的非零余数即为GCD。
   - 示例：gcd(48,18) → 48÷18=2余12 → gcd(18,12) → 18÷12=1余6 → gcd(12,6)=6）。‌
3. ‌**更相减损术**‌：
   - 通过对两数交替相减求GCD。
   - 示例：gcd(98,63)→98-63=35→63-35=28→35-28=7→28-7=21→21-7=14→14-7=7。‌

### 最小公倍数（LCM）

- 多个整数共有倍数的最小值。

- 示例：4和6的倍数序列分别为4→4,8,12,…和6→6,12,18,…，它们的最小公倍数为12。‌
- 所以求两个数的最小公倍数，可以先求出最大公约数，然后用上述公式求出它们的最小公倍数。

**‌计算方法**

1. ‌**分解质因数法**‌：
   - 将每个数分解为质因数乘积；
   - 取所有质因数的最高次幂相乘。
   - 示例：计算12和18的LCM，12=2²×3¹，18=2¹×3² → LCM=2²×3²=36。‌
2. ‌**公式法**‌（基于最大公约数GCD）：
   - 若两数为a和b，则 `LCM(a,b)=a×b/GCD(a,b)`。
   - 示例：计算24和36的LCM，GCD(24,36)=12 → LCM=(24×36)/12=72。‌
3. ‌**短除法**‌：
   - 用两数的共有质因数连续相除，直至商互质；
   - 所有除数与商的乘积即为LCM。
   - 示例：计算12和18的LCM，短除过程为2×3×2×3=36。‌

### 分解质因数

每个质因数都是质数，比如求值x的质因数，每次从小到大找，找到 i 后，记录，x/=i，然后重新从小到大找，直到x=1。

## 进制转换

- 短除法：循环取模、除以，10进制转为其它进制
  - 10转16进制，循环取模16、除以16
- 其它进制转为10进制，分割，依次乘
  - 16转10进制，分割，依次乘以16，从最大位数开始

## 字符相关

- 格式化输出：`System.out.printf("%.7f", p \* r \* r);`
- `‘0’`字符有对应的ASC码
- `char`转`int`： `char- ‘0’`
- `int`转`char`：`(char) ('0' + int)`
- 字符 A 的ascii码为 65
- 字符 a 为ascii码为 97 = 65 + 32
- `String`转`char`数组，`String`的`toCharArray()`方法

- 判断`char`是否为空格，`Character.isSpaceChar(c)`方法