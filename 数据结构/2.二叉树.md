# 二叉树

## 二叉树的性质

1. 节点的最大层次称为树的深度或高度
2. 二叉树第 i 层 至多有 2^(i-1) 个节点
3. 深度为k的二叉树至多有2^k- 1 个节点
4. 任何一颗二叉树，终端节点数为n0，度为2的节点数为n2，则n0 = n2 + 1 
5. n个节点的完全二叉树的深度为 ⌊logn⌋  +1 

## 满二叉树

对于编号为 i 的结点

- 若有双亲，双亲为 ⌊i/2⌋
- 若有左孩子，左孩子为 2i
- 若有右孩子，右孩子为 2i+1

## 完全二叉树

1. 深度为 ⌊logn⌋  +1 
2. 若 i 小于等于 ⌊n/2⌋  ，则 i 为分支结点，否则为叶子结点
3. 度为1的结点 ，只可能有一个，且只有左孩子、无右孩子
4. n为奇数：分支结点都有左孩子、右孩子
5. n为偶数：编号最大的分支结点（编号⌊n/2⌋）有左孩子，无右孩子
6. n个节点的完全二叉树，最后一个结点是 ⌊n/2⌋结点的孩子
7. 完全二叉树，可能是满二叉树，其子树：
   1. 有一棵一定是满二叉树
   2. 另一颗可能是满二叉树，也可能是完全二叉树

## 哈夫曼树

- 带权路径长度（Weighted Path Length, WPL）最小的二叉树，又称最优二叉树

## 二叉搜索树 BST

二叉搜索树（binary search tree，BST）

### 核心定义

1. **有序性**：若它的左子树不空，则**左子树上所有节点的值**均**小于**它的根节点的值。
2. **有序性**：若它的右子树不空，则**右子树上所有节点的值**均**大于**它的根节点的值。
3. **递归性**：它的左、右子树也分别为二叉搜索树。

这个定义是**递归的**，这意味着树中的每一个子树本身也是一个二叉搜索树。

### 核心特性

**中序遍历二叉搜索树，可以得到一个递增的有序序列。**

- **中序遍历**：先遍历左子树，再访问根节点，最后遍历右子树。
- 因为左子树 < 根 < 右子树，所以按“左-根-右”的顺序遍历，自然就是从小到大排列。

**时间复杂度**：平均情况 O(log n)，最坏情况O(n)。

**缺点**：普通的二叉搜索树（BST）在**极端情况下会退化成链表**。

**应用**：

- 直接基于 BST 的数据结构有 AVL 树，红黑树等等，拥有了自平衡性质，可以提供 logN 级别的增删查改效率。
- 还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的。

## 平衡二叉搜索树 

平衡二叉搜索树（Balanced Binary Search Tree）

**核心思想：**

- **在插入和删除节点时，通过特定的“旋转”操作，主动调整树的结构，使其始终保持“平衡”，从而保证树的高度始终在对数级别。**
- **控制根节点的左子树和右子树的高度差**，从而将树的高度 `h` 维持在 `O(log n)`。

### AVL 树

**平衡条件**：每个节点的平衡因子（左子树高度 - 右子树高度）只能是 -1, 0, 1。

**操作**：

1. 插入/删除节点后，从该节点向上回溯，找到第一个不平衡的祖先节点。
2. 根据这个节点的不平衡情况（LL, RR, LR, RL），执行对应的旋转操作。

**优点**：**提供了最严格的平衡**，因此查找效率是所有平衡BST中最高的。对于查找操作密集的场景非常适用。

**缺点**：为了维持高度平衡，**插入和删除操作可能需要频繁旋转**，性能略有损耗。

### 红黑树

**平衡条件**（通过5条规则定义）：

1. 每个节点非红即黑。
2. 根节点是黑色。
3. 所有叶子节点（NIL空节点）是黑色。
4. **红色节点的两个子节点必须是黑色**（即不能有连续的红色节点）。
5. 从任一节点到其每个叶子节点的所有路径都包含**相同数目的黑色节点**（即“黑高”相同）。

通过上述规则来确保**从根到叶子的最长路径不超过最短路径的2倍**。

**操作**：插入和删除节点时，可能会破坏上述规则（尤其是规则4）。需要通过**重新着色**和**旋转**来修正。其调整策略比AVL树更复杂，但调整次数通常更少。

**优点**：**插入和删除操作的效率更高**，因为不需要像AVL树那样追求绝对平衡，旋转次数更少。是一种一种折中的方案。

**缺点**：没有AVL树那么平衡，平均查找效率略低于AVL树。

**应用**：**极其广泛**。`C++ STL` 中的 `map`, `set`；`Java` 中的 `TreeMap`, `TreeSet`；`Linux` 内核的进程调度等都用的是红黑树。

## BST和BBST对比

| 特性              | 普通二叉搜索树           | AVL 树                                 | 红黑树                                        |
| :---------------- | :----------------------- | :------------------------------------- | :-------------------------------------------- |
| **平衡严格度**    | 无保证，可能退化         | **严格平衡**（高度差≤1）               | **近似平衡**（最长路径≤2倍最短路径）          |
| **查找效率**      | 平均 O(log n)，最坏 O(n) | **稳定 O(log n)**，**查找最快**        | 稳定 O(log n)，略慢于AVL                      |
| **插入/删除效率** | 平均 O(log n)，最坏 O(n) | 可能需要**频繁旋转**，效率较低         | **旋转次数较少**，效率更高                    |
| **适用场景**      | 不适用重要场景           | **大量查询，少量增删**（如数据库索引） | **大量增删**，或需要综合性能（如语言库的Map） |

1.  **空间换时间/操作换性能**：平衡BST通过**在插入和删除时付出额外的旋转开销**，来**换取查询时稳定的高效性能**。这是一种典型的权衡。
2.  **没有绝对的最优**：AVL树和红黑树各有优劣。如果你的应用**搜索非常频繁**，而插入删除操作不多，AVL树是很好的选择。如果你的**插入和删除操作也很频繁**，或者你需要一个**综合性能最优**的通用数据结构，红黑树是更流行的选择。这也是为什么你在标准库中看到的多是红黑树。
3.  **保证性能下限**：无论是AVL树还是红黑树，它们都保证了最坏情况下操作的时间复杂度仍然是 **O(log n)**，这是它们相对于普通BST最大的价值。

## B树

平衡的多路查找树 ，节点最大的孩子数目称为B树的阶，如：3阶B树、4阶B树等

一棵 **m阶** 的B树（B-tree of order m），是具有以下性质的树：

1. **节点子节点数限制**：
   - 每个节点最多有 **m** 个子节点。
   - 根节点至少可以有 **2** 个子节点（如果它不是叶子节点的话）。
   - 非根非叶的内部节点至少有 **⌈m/2⌉** 个子节点。（这个性质保证了节点的利用率）
2. **键的数量限制**：
   - 对于一个有 *k* 个子节点的非叶子节点，它包含 **k-1** 个键。
   - 根节点至少包含 **1** 个键。
   - 非根节点至少包含 **⌈m/2⌉ - 1** 个键。
3. **键的排列顺序**：
   - 所有键在一个节点内是**升序排列**的。
   - 对于一个键 `K_i`，其左子树中的所有键都 `小于` `K_i`，其右子树中的所有键都 `大于` `K_i`。（这是对二叉搜索树性质的扩展）
4. **叶子节点深度**：
   - 所有叶子节点都位于同一层。这体现了树的完美平衡。