# 图

## 连通

在一个图中，任意两个顶点之间都存在一条**路径**（直接或间接相连），那么这个图就是连通的

## 连通分量

| 特性           | 描述                                                         |
| :------------- | :----------------------------------------------------------- |
| **适用对象**   | **无向图**                                                   |
| **核心思想**   | **极大的连通子图**                                           |
| **“极大”含义** | 不能再加入任何原图的其他顶点而保持连通                       |
| **特殊情况**   | 单个没有边的顶点也是一个连通分量                             |
| **相关概念**   | 有向图中对应的是**强连通分量**和**弱连通分量**               |
| **常用算法**   | **DFS（深度优先搜索）**、**BFS（广度优先搜索）**、**并查集** |

### 无向图

无向图 G 的一个**极大连通子图** 称为 G的一个连通分量。

满足条件：

- **本身是连通的**。
- **再加入任何其他额外的顶点和边，它就不再连通**。及找不到另一个连通的子图，它既包含当前这个子图，又比它大。

简单来说，连通分量就是图中的一个“**独立模块**”或“**孤岛**”，在这个模块内部所有点都是相通的，但这个模块与图的其他部分没有任何连接。

示例，**一个包含 3个连通分量 的无向图：**

- **分量1**: 顶点 {A, B, C, D} 形成一个环，它们之间是连通的。
- **分量2**: 顶点 {E, F, G} 形成一个三角形，它们之间是连通的。
- **分量3**: 孤立的顶点 {H}，自身构成一个分量。
- 这三个分量之间**没有任何边**连接，证明了“极大连通子图”的定义。

```mermaid
graph TD
    subgraph Component1 [连通分量 1]
        A((A)) --- B((B))
        B --- C((C))
        C --- D((D))
        D --- A
    end

    subgraph Component2 [连通分量 2]
        E((E)) --- F((F))
        F --- G((G))
        G --- E
    end

    subgraph Component3 [连通分量 3]
        H((H))
    end
```

### 有向图

1. **强连通分量**
   - **定义**：在一个有向图的子图中，如果任意两个顶点 **u** 和 **v** 之间都存在一条从 **u** 到 **v** 的**有向路径**，同时也存在一条从 **v** 到 **u** 的**有向路径**，那么这个子图就是一个强连通分量。
   - **理解**：这意味着分量内的顶点是“双向互通”的。
2. **连通分量（弱连通分量）**
   - 如果忽略有向图中所有边的方向，将其视为无向图，然后找到的连通分量，就称为**弱连通分量**。

**通常，在没有特别说明的情况下，“连通分量”指的就是无向图中的概念。**

示例，**一个包含 3个强连通分量 的有向图：**

- **SCC1**: 顶点 {A, B, C} 形成一个有向环（A→B→C→A），它们之间是**强连通**的（任意两点可互达）。
- **SCC2**: 顶点 {D, E, F} 形成另一个有向环（D→E→F→D），它们之间也是强连通的。
- **SCC3**: 孤立的顶点 {G}，自身构成一个强连通分量。
- 分量之间有**有向边**连接（如 C→D, F→G），但这些边是单向的，不足以让两个分量合并为一个更大的强连通分量。

```mermaid
graph LR
    subgraph SCC1 [强连通分量 1]
        A(A) --> B(B)
        B --> C(C)
        C --> A
    end

    subgraph SCC2 [强连通分量 2]
        D(D) --> E(E)
        E --> F(F)
        F --> D
    end

    subgraph SCC3 [强连通分量 3]
        G(G)
    end

    C --> D
    F --> G
```



### 连通分量求解（算法）

寻找一个无向图的所有连通分量是图论中的一个基本问题，常用的算法是：

- **深度优先搜索** 或 **广度优先搜索**
- **并查集**

**DFS/BFS 的基本思路如下：**

1. 初始化一个访问标记数组，记录所有顶点是否已被访问过。
2. 从头开始遍历所有顶点。
3. 当遇到一个**未被访问**的顶点时，就从它开始进行一次**DFS**或**BFS**。
4. 这次**DFS**或**BFS**所能遍历到的**所有顶点**，就共同构成了**一个连通分量**。
5. 重复步骤3和4，直到图中所有的顶点都被访问过。

## 存储图(邻接表和邻接矩阵)

![image-20250915213622827](image-20250915213622827.png)

![image-20250915214819792](image-20250915214819792.png)

邻接表

- 优点：占用空间少
- 缺点：无法快速判断两个节点是否相邻

邻接矩阵

- 优点：可以快速判断两个节点是否相邻
- 缺点：需要更多的存储空间

示例：判断节点 1 是否和节点 3 相邻

- 邻接表，1 对应的邻居列表里查找 3 是否存在
- 邻接矩阵，只需判断matrix [1] [3]

使用哪一种方式实现图，要看具体情况

### 代码表示

**无权图**，代码表示邻接表和邻接矩阵

```java
/**
 * 邻接表
 * graph[x] 存储x的所以邻居节点
 */
List<Integer>[] graph;
/**
 * 邻接矩阵
 * matrix[x][y] 记录x是否有一条指向y的边
 */
boolean[][] matrix;
```

**加权图**，代码表示邻接表和邻接矩阵

```java
/**
 * 邻接表
 * graph[x] 存储x的所以邻居节点以及对应的权重
 */
List<int[]>[] graph;
/**
 * matrix[x][y] 记录x指向y的边的权重，0表示不相邻
 */
int[][] matrix;
```

## 度：每个节点相连的边的条数

有向图的边有方向，所以有向图中每个节点「度」被细分为入度（indegree）和出度（outdegree）。

比如上图：其中节点 3 的入度为 3（有三条边指向它），出度为 1（它有 1 条边指向别的节点）。

## 图和多叉树最大的区别是：图是可能包含环的

- 从图的某一个节点开始遍历，有可能走了一圈又回到这个节点。
- 而树不会出现这种情况，从某个节点出发必然走到叶子节点，绝不可能回到它自身。
- 所以，如果图包含环，遍历框架需要 `visited` 数组进行辅助，防止再次访问。

## 图的遍历

多叉树的 DFS 遍历框架如下：

```java
public void traverse(TreeNode root) {
    if (root == null) return;
    // 前序位置
    for (TreeNode child : root.children) {
        traverse(child);
    }
    // 后序位置
}
```

## 图的DFS遍历框架

```java
// 记录被遍历过的节点
private boolean[] visited;
// 记录从起点到当前节点的路径
private boolean[] onPath;
/**
 * 图遍历框架
 */
public void traverse(Graph graph, int s) {
    if (visited[s]) return;
    // 经过节点s，标记为已遍历
    visited[s] = true;
    // 做选择：标记节点s在路径上
    onPath[s] = true;
    for (int neighbor : graph.neighbor(s)) {
        traverse(graph, neighbor);
    }
    // 撤销选择：节点s离开路径
    onPath[s] = false;
}
```

visited 数组和 onPath 数组的区别：

- visited：记录访问过的节点，若无环不需要visited。
- onPath：记录路径，处理路径相关的问题需要 onPath。

## 回溯算法和DFS 算法的区别

DFS 关注 **节点**，在「节点」上做选择和撤销选择(**for循环外面**)

```java
public void traverse(TreeNode root) {
    if (root == null) return;
    // for循环外面
    System.out.println("进入节点%s", root);
    for (TreeNode child : root.children) {
        traverse(child);
    }
    System.out.println("离开节点%s", root);
}
```



回溯 关注 **树枝**，在「树枝」上做选择和撤销选择(**for循环里面**)

```java
public void backtrack(TreeNode root) {
    if (root == null) return;
    for (TreeNode child : root.children) {
        // for循环里面
        // 做选择
        System.out.println("从%s到%s", root, child);
        backtrack(child);
        // 撤销选择
        System.out.println("从%s到%s", child, root);
    }
}
```

